00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.01
Created On: 6/4/2014 6:07:56 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Derek Willms, Binh Nguyen, Brian Quigley
00000000                             4  * Date       : 6/01/2014
00000000                             5  * Description: Translate machine codes back to instructions
00000000                             6  *              based on a user input range of address.
00000000                             7  *              Minimum starting address: $00007000
00000000                             8  *              Maximum ending address: $00FFFFFE
00000000                             9  *-----------------------------------------------------------
00000000                            10                  
00001000                            11  START:          ORG     $1000
00001000                            12  
00001000                            13  start           
00001000  4FF9 00007000             14      LEA     stack,SP                        * Load the Stack Pointer
00001006  43F9 0000278E             15      LEA     greeting,A1                     * Assign greeting to A1
0000100C  103C 000E                 16      MOVE.B  #14,D0                          * Assign prompt task code to D0
00001010  4E4F                      17      TRAP    #15                             * Display greeting
00001012  13FC 0000 0000252C        18      MOVE.B  #0,line_count                   * Initial line count for display
0000101A                            19                  
0000101A                            20  get_start       
0000101A  43F9 0000252E             21      LEA     start_prompt,A1                 * Assign starting address prompt to A1
00001020  103C 000E                 22      MOVE.B  #14,D0                          * Assign prompt task code to D0
00001024  4E4F                      23      TRAP    #15                             * Display starting address prompt
00001026                            24                  
00001026  43F9 000026AB             25      LEA     start_input,A1                  * Assign start_input as address to store input
0000102C  103C 0002                 26      MOVE.B  #2,D0                           * Assign input task code to D0
00001030  4E4F                      27      TRAP    #15                             * Store user input in A1
00001032                            28                  
00001032  4EB9 0000242C             29      JSR     ascii_to_hex                    * Translate ASCII input to HEX
00001038  4EB9 000024A2             30      JSR     even_check                      * Check if given address is odd
0000103E  B67C FFFF                 31      CMP.W   #-1,D3                          * Check result of odd check
00001042  67D6                      32      BEQ     get_start                       * If odd, display an error and ask for new starting address
00001044                            33                  
00001044  2A3C 00007000             34      MOVE.L  #begin,D5                       * Assign minimum address bound to D5
0000104A  B685                      35      CMP.L   D5,D3                           * Compare address to minimum bound
0000104C  6D00 1444                 36      BLT     bound_error                     * Error if address is below minimum
00001050  2A3C 00FFFFFE             37      MOVE.L  #end,D5                         * Assign maximum address bound to D5
00001056  B685                      38      CMP.L   D5,D3                           * Compare address to maximum bound
00001058  6E00 1438                 39      BGT     bound_error                     * Error if address is above maximum
0000105C  2C43                      40      MOVEA.L D3,A6                           * Save the lower address into A6
0000105E                            41                  
0000105E                            42  get_end         
0000105E  43F9 0000255D             43      LEA     end_prompt,A1                   * Assign ending address prompt to A1
00001064  103C 000E                 44      MOVE.B  #14,D0                          * Assign prompt task code to D0
00001068  4E4F                      45      TRAP    #15                             * Display ending address prompt
0000106A                            46                  
0000106A  43F9 000026FB             47      LEA     end_input,A1                    * Assign end_input as address to store input
00001070  103C 0002                 48      MOVE.B  #2,D0                           * Assign input task code to D0
00001074  4E4F                      49      TRAP    #15                             * Store user input in A1
00001076                            50                  
00001076  4EB9 0000242C             51      JSR     ascii_to_hex                    * Translate ASCII input to HEX
0000107C  4EB9 000024A2             52      JSR     even_check                      * Check if given address is odd
00001082  B67C FFFF                 53      CMP.W   #-1,D3                          * Check result of odd check
00001086  67D6                      54      BEQ     get_end                         * If odd, display an error and ask for new starting address
00001088                            55                  
00001088  B68E                      56      CMP.L   A6,D3                           * Compare address to lower address
0000108A  6F00 1406                 57      BLE     bound_error                     * Error if address is below or equal lower address
0000108E  B685                      58      CMP.L   D5,D3                           * Compare address to maximum bound
00001090  6E00 1400                 59      BGT     bound_error                     * Error if address is above maximum
00001094  2C03                      60      MOVE.L  D3,D6                           * Save the upper address into D6
00001096                            61                  
00001096  4282                      62      CLR.L   D2                              * Clear D2
00001098  4283                      63      CLR.L   D3                              * Clear D3
0000109A  4285                      64      CLR.L   D5                              * Clear D5                
0000109C                            65  
0000109C                            66  main            
0000109C  4280                      67      CLR.L   D0                              * Clear D0
0000109E  4281                      68      CLR.L   D1                              * Clear D1
000010A0  200E                      69      MOVE.L  A6,D0                           * Get current memory pointer in D0
000010A2  123C 0004                 70      MOVE.B  #4,D1                           * Size for address is 4 bytes
000010A6  227C 0000265B             71      MOVE.L  #buffer,A1                      * Set A1 to point to the print buffer
000010AC  4EB9 000024C8             72      JSR     hex_to_ascii                    * Translate hex to ascii
000010B2  12FC 0009                 73      MOVE.B  #$9,(A1)+                       * Add a tab
000010B6  12BC 0000                 74      MOVE.B  #$00,(A1)                       * Add terminator              
000010BA  4280                      75      CLR.L   D0                              * Clear D0   
000010BC  103C 000E                 76      MOVE.B  #14,D0                          * Load Trap task number 14 for printing
000010C0  43F9 0000265B             77      LEA     buffer,A1                       * Load print buffer into A1 
000010C6  4E4F                      78      TRAP    #15                             * Print the buffer
000010C8  227C 0000265B             79      MOVE.L  #buffer,A1                      * Set A1 to point to the print buffer
000010CE  6000 005C                 80      BRA     op_code                         * Begin decode 
000010D2                            81                  
000010D2                            82  Print           
000010D2  12BC 0000                 83      MOVE.B  #$00,(A1)                       * Add terminator              
000010D6  4280                      84      CLR.L   D0                              * Clear D0   
000010D8  103C 000D                 85      MOVE.B  #13,D0                          * Load Trap task number 13 for printing
000010DC  43F9 0000265B             86      LEA     buffer,A1                       * Load print buffer into A1 
000010E2  4E4F                      87      TRAP    #15                             * Print the buffer              
000010E4  BC8E                      88      CMP.L   A6,D6                           * Compare current memory pointer with ending address 
000010E6  6F00 1148                 89      BLE     end_check                       * Less than equal zero, reach the end
000010EA  5239 0000252C             90      ADD.B   #1,line_count                   * Increase line count by 1
000010F0  0C39 0014 0000252C        91      CMP.B   #max_line,line_count            * Compare to max line
000010F8  6700 0004                 92      BEQ     print_break
000010FC                            93      
000010FC                            94  Print_cont
000010FC  609E                      95      BRA     main                            * Go to next memory
000010FE                            96  
000010FE                            97  print_break
000010FE  13FC 0000 0000252C        98      MOVE.B  #0,line_count                   * Reset line count
00001106  43F9 00002633             99      LEA     empty_line,A1                   * Assign empty line to A1
0000110C  103C 000E                100      MOVE.B  #14,D0                          * Assign prompt task code to D0
00001110  4E4F                     101      TRAP    #15                             * Display an empty line  
00001112  43F9 00002618            102      LEA     screen_enter,A1                 * String asking user to press enter
00001118  103C 000E                103      MOVE.B  #14,D0                          * Assign prompt task code to D0
0000111C  4E4F                     104      TRAP    #15                             * Display string
0000111E  43F9 0000274B            105      LEA     discard,A1                      * Assign discard as address to store input
00001124  103C 0002                106      MOVE.B  #2,D0                           * Assign input task code to D0
00001128  4E4F                     107      TRAP    #15                             * Store user input in A1
0000112A  60D0                     108      BRA     Print_cont                      * Go back to next instructions        
0000112C                           109  
0000112C                           110  *////////////////////////////////////////////////////////////////////////////////////////
0000112C                           111  *op_code: get the data from current memory pointer, advance the memory pointer, separate 
0000112C                           112  *         the bits, and jump to the corresponding op_code decoding
0000112C                           113  *D0: Internal 
0000112C                           114  *D1: Internal
0000112C                           115  *D2: Store 3 bits for Source REGISTER
0000112C                           116  *D3: Store 3 bits for Source MODE
0000112C                           117  *D4: Store 3 bits for Destination MODE
0000112C                           118  *D5: Store 3 bits for Destination REGISTER
0000112C                           119  *current: Store the WORD data
0000112C                           120  *////////////////////////////////////////////////////////////////////////////////////////                
0000112C                           121  op_code         
0000112C  41F9 00001182            122      LEA     jmp_table,A0                    *Index into the table
00001132  4280                     123      CLR.L   D0                              *Zero it
00001134                           124                  
00001134  33DE 0000252A            125      MOVE.W  (A6)+,current                   *Get WORD and advance memory pointer                
0000113A  3039 0000252A            126      MOVE.W  current,D0                      *Copy WORD to D0            
00001140  3200                     127      MOVE.W  D0,D1                           *Copy Word data to D1
00001142  48E7 8000                128      MOVEM.L D0,-(SP)                        *Copy Word data to the stack
00001146                           129      
00001146  0241 0007                130      ANDI.W  #$0007,D1                       *Get last 3 bits Source REG
0000114A  1401                     131      MOVE.B  D1,D2                           *Store in D2
0000114C                           132      
0000114C  E648                     133      LSR.W   #3,D0                           *Rotate D0 right 3 bits
0000114E  3200                     134      MOVE.W  D0,D1                           *Copy Word to D1
00001150  0241 0007                135      ANDI.W  #$0007,D1                       *Get last 3 bits Source MODE
00001154  1601                     136      MOVE.B  D1,D3                           *Store in D3
00001156                           137      
00001156  E648                     138      LSR.W   #3,D0                           *Rotate D0 right 3 bits
00001158  3200                     139      MOVE.W  D0,D1                           *Copy Word to D1
0000115A  0241 0007                140      ANDI.W  #$0007,D1                       *Get last 3 bits Dest MODE
0000115E  1801                     141      MOVE.B  D1,D4                           *Store in D4
00001160                           142      
00001160  E648                     143      LSR.W   #3,D0                           *Rotate D0 right 3 bits
00001162  3200                     144      MOVE.W  D0,D1                           *Copy Word to D1
00001164  0241 0007                145      ANDI.W  #$0007,D1                       *Get last 3 bits Dest REG
00001168  1A01                     146      MOVE.B  D1,D5                           *Store in D5
0000116A                           147      
0000116A  4CDF 0001                148      MOVEM.L (SP)+,D0                        *Pop Word data from stack to D0
0000116E  4281                     149      CLR.L   D1                              *Clear D1
00001170                           150  
00001170  123C 000C                151      MOVE.B  #shift,D1                       *Shift 12 bits to the right 
00001174  E268                     152      LSR.W   D1,D0                           *Move the bits
00001176                           153      
00001176  4281                     154      CLR.L   D1                              *Clear D1
00001178  1200                     155      MOVE.B  D0,D1                           *Copy 4 bits to D1
0000117A                           156      
0000117A  C0FC 0006                157      MULU    #6,D0                           *Form offset
0000117E  4EB0 0000                158      JSR     0(A0,D0)                        *Jump indirect with index
00001182                           159  
00001182                           160  jmp_table
00001182  4EF9 000011E2            161      JMP     code0000                        *Bit manipulation/MOVEP/Immediate
00001188  4EF9 0000133C            162      JMP     code0001                        *Move Byte
0000118E  4EF9 00001394            163      JMP     code0010                        *Move Long
00001194  4EF9 000013E0            164      JMP     code0011                        *Move Word
0000119A  4EF9 00001442            165      JMP     code0100                        *Miscellaneous
000011A0  4EF9 00001764            166      JMP     code0101                        *ADDQ/SUBQ/Scc/DBcc
000011A6  4EF9 000017DC            167      JMP     code0110                        *BSR,BRA,Bcc
000011AC  4EF9 00001952            168      JMP     code0111                        *MOVEQ
000011B2  4EF9 00001956            169      JMP     code1000                        *OR/DIV/SBCD
000011B8  4EF9 00001A4C            170      JMP     code1001                        *SUB/SUBX
000011BE  4EF9 00001AFE            171      JMP     code1010                        *Unassigned
000011C4  4EF9 00001B02            172      JMP     code1011                        *CMP/EOR
000011CA  4EF9 00001BBA            173      JMP     code1100                        *AND/MUL/ABCD/EXG
000011D0  4EF9 00001C10            174      JMP     code1101                        *ADD/ADDA/ADDX
000011D6  4EF9 00001D1A            175      JMP     code1110                        *Shift/Rotate
000011DC  4EF9 000021F0            176      JMP     code1111                        *Special/Reserved
000011E2                           177  
000011E2                           178  *////////////////////////////////////////////////////////////////////////////////////////
000011E2                           179  *code0000: Bit manipulation/MOVEP/Immediate
000011E2                           180  * ORI - CMPI - BCLR
000011E2                           181  *////////////////////////////////////////////////////////////////////////////////////////    
000011E2                           182  code0000
000011E2  1004                     183      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
000011E4  E408                     184      LSR.B   #2,D0                           * Shift right by 2 bits
000011E6  0200 0001                185      ANDI.B  #$01,D0                         * Get bit 8
000011EA  B03C 0001                186      CMP.B   #1,D0                           * Check if 1
000011EE  6700 002A                187      BEQ     BCLR_dynamic_check
000011F2                           188  
000011F2  3039 0000252A            189      MOVE.W  current,D0                      * Copy the WORD data to D0
000011F8  EC48                     190      LSR.W   #6,D0                           * Shift right by 6 bits
000011FA  0240 003F                191      ANDI.W  #$3F,D0                         * Get bits 6-11
000011FE  B03C 0022                192      CMP.B   #34,D0                          * Check if 34
00001202  6700 00F8                193      BEQ     is_BCLR_static                        
00001206                           194  
00001206  BA3C 0000                195      CMP.B   #0,D5                           * ORI
0000120A  6700 001A                196      BEQ     is_ORI
0000120E                           197      
0000120E  BA3C 0006                198      CMP.B   #6,D5                           * CMPI
00001212  6700 005C                199      BEQ     is_CMPI
00001216                           200      
00001216  6000 0FDC                201      BRA     data_error                      * Other not required instructions
0000121A                           202      
0000121A                           203  BCLR_dynamic_check    
0000121A  B83C 0006                204      CMP.B   #6,D4                           * BCLR dynamic
0000121E  6700 009E                205      BEQ     is_BCLR_dynamic
00001222                           206      
00001222  6000 0FD0                207      BRA     data_error                      * Other not required instructions    
00001226                           208      
00001226                           209  is_ORI
00001226  B63C 0001                210      CMP.B   #1,D3                           * Check invalid EA mode
0000122A  6700 0FC8                211      BEQ     data_error
0000122E  12FC 004F                212      MOVE.B  #'O',(A1)+
00001232  12FC 0052                213      MOVE.B  #'R',(A1)+
00001236  12FC 0049                214      MOVE.B  #'I',(A1)+
0000123A  1004                     215      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
0000123C  0200 0003                216      ANDI.B  #$03,D0                         * Get bit 6-7 for size
00001240  4EB9 000023C8            217      JSR     get_size                        * Get size
00001246  13FC 0005 0000252D       218      MOVE.B  #5,char_count                   * Increase character counts
0000124E  4EB9 0000240A            219      JSR     get_space                       * Get more spaces for alignment
00001254  4281                     220      CLR.L   D1
00001256  1200                     221      MOVE.B  D0,D1                           * Copy byte size to D1
00001258  4EB9 000023B2            222      JSR     immediate_data                  * Get immediate data
0000125E  4280                     223      CLR.L   D0
00001260  1001                     224      MOVE.B  D1,D0                           * Copy byte size back to D0
00001262  12FC 002C                225      MOVE.B  #',',(A1)+
00001266  4EB9 000022A4            226      JSR     EAMode                          * Get destination EA
0000126C  6000 FE64                227      BRA     Print       
00001270                           228  
00001270                           229  is_CMPI
00001270  B63C 0001                230      CMP.B   #1,D3                           * Check invalid EA mode
00001274  6700 0F7E                231      BEQ     data_error
00001278  12FC 0043                232      MOVE.B  #'C',(A1)+
0000127C  12FC 004D                233      MOVE.B  #'M',(A1)+
00001280  12FC 0050                234      MOVE.B  #'P',(A1)+
00001284  12FC 0049                235      MOVE.B  #'I',(A1)+
00001288  1004                     236      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
0000128A  0200 0003                237      ANDI.B  #$03,D0                         * Get bit 6-7 for size
0000128E  4EB9 000023C8            238      JSR     get_size                        * Get size
00001294  13FC 0006 0000252D       239      MOVE.B  #6,char_count                   * Increase character counts
0000129C  4EB9 0000240A            240      JSR     get_space                       * Get more spaces for alignment    
000012A2  4281                     241      CLR.L   D1
000012A4  1200                     242      MOVE.B  D0,D1                           * Copy byte size to D1
000012A6  4EB9 000023B2            243      JSR     immediate_data                  * Get immediate data
000012AC  4280                     244      CLR.L   D0
000012AE  1001                     245      MOVE.B  D1,D0                           * Copy byte size back to D0
000012B0  12FC 002C                246      MOVE.B  #',',(A1)+
000012B4  4EB9 000022A4            247      JSR     EAMode                          * Get destination EA
000012BA  6000 FE16                248      BRA     Print    
000012BE                           249  
000012BE                           250  is_BCLR_dynamic
000012BE  B63C 0001                251      CMP.B   #1,D3                           * Check invalid EA mode
000012C2  6700 0F30                252      BEQ     data_error
000012C6  12FC 0042                253      MOVE.B  #'B',(A1)+
000012CA  12FC 0043                254      MOVE.B  #'C',(A1)+
000012CE  12FC 004C                255      MOVE.B  #'L',(A1)+
000012D2  12FC 0052                256      MOVE.B  #'R',(A1)+
000012D6  13FC 0004 0000252D       257      MOVE.B  #4,char_count                   * Increase character counts
000012DE  4EB9 0000240A            258      JSR     get_space                       * Get more spaces for alignment    
000012E4  12FC 0044                259      MOVE.B  #'D',(A1)+                  
000012E8  0645 0030                260      ADD     #$30,D5                         *Convert REG# to ASCII
000012EC  12C5                     261      MOVE.B  D5,(A1)+                        *Add to buffer
000012EE  12FC 002C                262      MOVE.B  #',',(A1)+
000012F2  4EB9 000022A4            263      JSR     EAMode                          * Get destination EA        
000012F8  6000 FDD8                264      BRA     Print    
000012FC                           265  
000012FC                           266  is_BCLR_static
000012FC  B63C 0001                267      CMP.B   #1,D3                           * Check invalid EA mode
00001300  6700 0EF2                268      BEQ     data_error
00001304  12FC 0042                269      MOVE.B  #'B',(A1)+
00001308  12FC 0043                270      MOVE.B  #'C',(A1)+
0000130C  12FC 004C                271      MOVE.B  #'L',(A1)+
00001310  12FC 0052                272      MOVE.B  #'R',(A1)+
00001314  13FC 0004 0000252D       273      MOVE.B  #4,char_count                   * Increase character counts
0000131C  4EB9 0000240A            274      JSR     get_space                       * Get more spaces for alignment   
00001322  4280                     275      CLR.L   D0
00001324  103C 0001                276      MOVE.B  #1,D0                           * byte size is 2
00001328  4EB9 000023B2            277      JSR     immediate_data                  * get immediate data
0000132E  12FC 002C                278      MOVE.B  #',',(A1)+
00001332  4EB9 000022A4            279      JSR     EAMode                          * Get destination EA        
00001338  6000 FD98                280      BRA     Print      
0000133C                           281  
0000133C                           282  *////////////////////////////////////////////////////////////////////////////////////////
0000133C                           283  *code0001: MOVE Byte
0000133C                           284  *////////////////////////////////////////////////////////////////////////////////////////  
0000133C                           285  code0001
0000133C  B83C 0001                286      CMP.B   #1,D4                           * Check invalid EA mode
00001340  6700 0EB2                287      BEQ     data_error
00001344  12FC 004D                288      MOVE.B  #'M',(A1)+
00001348  12FC 004F                289      MOVE.B  #'O',(A1)+
0000134C  12FC 0056                290      MOVE.B  #'V',(A1)+
00001350  12FC 0045                291      MOVE.B  #'E',(A1)+
00001354  12FC 002E                292      MOVE.B  #'.',(A1)+
00001358  12FC 0042                293      MOVE.B  #'B',(A1)+
0000135C  13FC 0006 0000252D       294      MOVE.B  #6,char_count                   * Increase character counts
00001364  4EB9 0000240A            295      JSR     get_space                       * Get more spaces for alignment    
0000136A  4280                     296      CLR.L   D0                              *Clear D0
0000136C  103C 0001                297      MOVE.B  #1,D0                           *size is 1 byte   
00001370  4EB9 000022A4            298      JSR     EAMode                          *Jump to EAMode
00001376  12FC 002C                299      MOVE.B  #',',(A1)+ 
0000137A  4282                     300      CLR.L   D2
0000137C  4283                     301      CLR.L   D3
0000137E  1604                     302      MOVE.B  D4,D3                           *Get Destination MODE
00001380  1405                     303      MOVE.B  D5,D2                           *Get Source REG 
00001382  B63C 0001                304      CMP.B   #1,D3                           *An not allowed
00001386  6700 0E6C                305      BEQ     data_error
0000138A  4EB9 000022A4            306      JSR     EAMode                          *Jump to EAMode
00001390                           307      
00001390  6000 FD40                308      BRA     Print
00001394                           309  
00001394                           310  *////////////////////////////////////////////////////////////////////////////////////////
00001394                           311  *code0001: MOVE Long
00001394                           312  *//////////////////////////////////////////////////////////////////////////////////////// 
00001394                           313  code0010    
00001394  12FC 004D                314      MOVE.B  #'M',(A1)+
00001398  12FC 004F                315      MOVE.B  #'O',(A1)+
0000139C  12FC 0056                316      MOVE.B  #'V',(A1)+
000013A0  12FC 0045                317      MOVE.B  #'E',(A1)+ 
000013A4  4EB9 0000142C            318      JSR     MOVEA_check                     *Check for MOVEA       
000013AA  12FC 002E                319      MOVE.B  #'.',(A1)+
000013AE  12FC 004C                320      MOVE.B  #'L',(A1)+
000013B2  5C39 0000252D            321      ADD.B   #6,char_count                   * Increase character counts
000013B8  4EB9 0000240A            322      JSR     get_space                       * Get more spaces for alignment      
000013BE  4280                     323      CLR.L   D0                              *Clear D0
000013C0  103C 0004                324      MOVE.B  #4,D0                           *size is 4 bytes     
000013C4  4EB9 000022A4            325      JSR     EAMode                          *Jump to EAMode 
000013CA  12FC 002C                326      MOVE.B  #',',(A1)+  
000013CE  4282                     327      CLR.L   D2
000013D0  4283                     328      CLR.L   D3
000013D2  1604                     329      MOVE.B  D4,D3                           *Get Destination MODE
000013D4  1405                     330      MOVE.B  D5,D2                           *Get Source REG
000013D6  4EB9 000022A4            331      JSR     EAMode                          *Jump to EAMode
000013DC                           332      
000013DC  6000 FCF4                333      BRA     Print
000013E0                           334  
000013E0                           335  
000013E0                           336  *////////////////////////////////////////////////////////////////////////////////////////
000013E0                           337  *code0011: MOVE Word
000013E0                           338  *//////////////////////////////////////////////////////////////////////////////////////// 
000013E0                           339  code0011    
000013E0  12FC 004D                340      MOVE.B  #'M',(A1)+
000013E4  12FC 004F                341      MOVE.B  #'O',(A1)+
000013E8  12FC 0056                342      MOVE.B  #'V',(A1)+
000013EC  12FC 0045                343      MOVE.B  #'E',(A1)+  
000013F0  4EB9 0000142C            344      JSR     MOVEA_check                     *Check for MOVEA   
000013F6  12FC 002E                345      MOVE.B  #'.',(A1)+
000013FA  12FC 0057                346      MOVE.B  #'W',(A1)+
000013FE  5C39 0000252D            347      ADD.B   #6,char_count                   * Increase character counts
00001404  4EB9 0000240A            348      JSR     get_space                       * Get more spaces for alignment    
0000140A  4280                     349      CLR.L   D0                              *Clear D0
0000140C  103C 0002                350      MOVE.B  #2,D0                           *size is 2 bytes      
00001410  4EB9 000022A4            351      JSR     EAMode                          *Jump to EAMode 
00001416  12FC 002C                352      MOVE.B  #',',(A1)+ 
0000141A  4282                     353      CLR.L   D2
0000141C  4283                     354      CLR.L   D3
0000141E  1604                     355      MOVE.B  D4,D3                           *Get Destination MODE
00001420  1405                     356      MOVE.B  D5,D2                           *Get Source REG
00001422  4EB9 000022A4            357      JSR     EAMode                          *Jump to EAMode
00001428                           358      
00001428  6000 FCA8                359      BRA     Print
0000142C                           360  
0000142C                           361  *////////////////////////////////////////////////////////////////////////////////////////
0000142C                           362  *MOVEA_check: check if MOVEA, then add 'A' to print buffer
0000142C                           363  *D4: hold the Destination MODE for comparison
0000142C                           364  *//////////////////////////////////////////////////////////////////////////////////////// 
0000142C                           365  MOVEA_check
0000142C  B83C 0001                366      CMP.B   #1,D4                           
00001430  6700 0004                367      BEQ     is_MOVEA
00001434  4E75                     368      RTS
00001436                           369  
00001436                           370  is_MOVEA
00001436  12FC 0041                371      MOVE.B  #'A',(A1)+
0000143A  5239 0000252D            372      ADD.B   #1,char_count                   * Increase character count
00001440  4E75                     373      RTS
00001442                           374  
00001442                           375  *////////////////////////////////////////////////////////////////////////////////////////
00001442                           376  *code0100: Miscellaneous
00001442                           377  * NOP - NEG - RTS - JSR - MOVEM - LEA
00001442                           378  *////////////////////////////////////////////////////////////////////////////////////////
00001442                           379  code0100
00001442  3039 0000252A            380      MOVE.W  current,D0                      * Copy the WORD data to D0
00001448  B07C 4E71                381      CMP.W   #$4E71,D0                       * NOP
0000144C  6700 0058                382      BEQ     is_NOP
00001450                           383  
00001450  B07C 4E75                384      CMP.W   #$4E75,D0                       * RTS
00001454  6700 0060                385      BEQ     is_RTS
00001458                           386  
00001458  E048                     387      LSR.W   #8,D0                           * Shift right by 8 bits
0000145A  0240 000F                388      ANDI.W  #$0F,D0                         * Get bits 8-11
0000145E  B03C 0004                389      CMP.B   #4,D0                           * Check if 4
00001462  6700 0062                390      BEQ     is_NEG                          * NEG
00001466                           391  
00001466  B83C 0007                392      CMP.B   #7,D4                           * LEA
0000146A  6700 0092                393      BEQ     is_LEA
0000146E                           394  
0000146E  3039 0000252A            395      MOVE.W  current,D0                      * Copy the WORD data to D0
00001474  EC48                     396      LSR.W   #6,D0                           * Shift right by 6 bits
00001476  0240 003F                397      ANDI.W  #$3F,D0                         * Get bits 6-11
0000147A  B03C 003A                398      CMP.B   #58,D0                          * JSR
0000147E  6700 00D0                399      BEQ     is_JSR                                          
00001482                           400  
00001482  B03C 0022                401      CMP.B   #34,D0                          * MOVEM reg to mem word
00001486  6700 010C                402      BEQ     is_MOVEM_word_reg_to_mem
0000148A                           403  
0000148A  B03C 0023                404      CMP.B   #35,D0                          * MOVEM reg to mem long
0000148E  6700 014A                405      BEQ     is_MOVEM_long_reg_to_mem
00001492                           406  
00001492  B03C 0032                407      CMP.B   #50,D0                          * MOVEM mem to reg word
00001496  6700 0188                408      BEQ     is_MOVEM_word_mem_to_reg
0000149A                           409  
0000149A  B03C 0033                410      CMP.B   #51,D0                          * MOVEM mem to reg long
0000149E  6700 01C6                411      BEQ     is_MOVEM_long_mem_to_reg     
000014A2                           412      
000014A2  6000 0D50                413      BRA     data_error                      * Other not required instructions
000014A6                           414  
000014A6                           415  is_NOP
000014A6  12FC 004E                416      MOVE.B  #'N',(A1)+
000014AA  12FC 004F                417      MOVE.B  #'O',(A1)+
000014AE  12FC 0050                418      MOVE.B  #'P',(A1)+
000014B2  6000 FC1E                419      BRA     Print
000014B6                           420  
000014B6                           421  is_RTS
000014B6  12FC 0052                422      MOVE.B  #'R',(A1)+
000014BA  12FC 0054                423      MOVE.B  #'T',(A1)+
000014BE  12FC 0053                424      MOVE.B  #'S',(A1)+
000014C2  6000 FC0E                425      BRA     Print
000014C6                           426  
000014C6                           427  is_NEG
000014C6  B63C 0001                428      CMP.B   #1,D3                           * Check invalid EA mode
000014CA  6700 0D28                429      BEQ     data_error
000014CE  12FC 004E                430      MOVE.B  #'N',(A1)+
000014D2  12FC 0045                431      MOVE.B  #'E',(A1)+
000014D6  12FC 0047                432      MOVE.B  #'G',(A1)+        
000014DA  1004                     433      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
000014DC  0200 0003                434      ANDI.B  #$03,D0                         * Get bit 6-7 for size
000014E0  4EB9 000023C8            435      JSR     get_size                        * Get size
000014E6  13FC 0005 0000252D       436      MOVE.B  #5,char_count                   * Increase character counts
000014EE  4EB9 0000240A            437      JSR     get_space                       * Get more spaces for alignment    
000014F4  4EB9 000022A4            438      JSR     EAMode                          * Get destination EA
000014FA  6000 FBD6                439      BRA     Print
000014FE                           440  
000014FE                           441  is_LEA
000014FE  B63C 0000                442      CMP.B   #0,D3                           * Check invalid EA mode
00001502  6700 0CF0                443      BEQ     data_error
00001506  B63C 0001                444      CMP.B   #1,D3                           * Check invalid EA mode
0000150A  6700 0CE8                445      BEQ     data_error
0000150E  B63C 0003                446      CMP.B   #3,D3                           * Check invalid EA mode
00001512  6700 0CE0                447      BEQ     data_error
00001516  B63C 0004                448      CMP.B   #4,D3                           * Check invalid EA mode
0000151A  6700 0CD8                449      BEQ     data_error
0000151E  12FC 004C                450      MOVE.B  #'L',(A1)+
00001522  12FC 0045                451      MOVE.B  #'E',(A1)+
00001526  12FC 0041                452      MOVE.B  #'A',(A1)+
0000152A  13FC 0003 0000252D       453      MOVE.B  #3,char_count                   * Increase character counts
00001532  4EB9 0000240A            454      JSR     get_space                       * Get more spaces for alignment   
00001538  4EB9 000022A4            455      JSR     EAMode                          * Get EA
0000153E  12FC 002C                456      MOVE.B  #',',(A1)+
00001542  12FC 0041                457      MOVE.B  #'A',(A1)+                  
00001546  0645 0030                458      ADD     #$30,D5                         *Convert REG# to ASCII
0000154A  12C5                     459      MOVE.B  D5,(A1)+                        *Add to buffer
0000154C  6000 FB84                460      BRA     Print         
00001550                           461  
00001550                           462  is_JSR
00001550  B63C 0000                463      CMP.B   #0,D3                           * Check invalid EA mode
00001554  6700 0C9E                464      BEQ     data_error
00001558  B63C 0001                465      CMP.B   #1,D3                           * Check invalid EA mode
0000155C  6700 0C96                466      BEQ     data_error
00001560  B63C 0003                467      CMP.B   #3,D3                           * Check invalid EA mode
00001564  6700 0C8E                468      BEQ     data_error
00001568  B63C 0004                469      CMP.B   #4,D3                           * Check invalid EA mode
0000156C  6700 0C86                470      BEQ     data_error
00001570  12FC 004A                471      MOVE.B  #'J',(A1)+
00001574  12FC 0053                472      MOVE.B  #'S',(A1)+
00001578  12FC 0052                473      MOVE.B  #'R',(A1)+
0000157C  13FC 0003 0000252D       474      MOVE.B  #3,char_count                   * Increase character counts
00001584  4EB9 0000240A            475      JSR     get_space                       * Get more spaces for alignment  
0000158A  4EB9 000022A4            476      JSR     EAMode                          * Get EA
00001590  6000 FB40                477      BRA     Print
00001594                           478  
00001594                           479  is_MOVEM_word_reg_to_mem
00001594  B63C 0000                480      CMP.B   #0,D3                           * Check invalid EA mode
00001598  6700 0C5A                481      BEQ     data_error
0000159C  B63C 0001                482      CMP.B   #1,D3                           * Check invalid EA mode
000015A0  6700 0C52                483      BEQ     data_error
000015A4  B63C 0003                484      CMP.B   #3,D3                           * Check invalid EA mode
000015A8  6700 0C4A                485      BEQ     data_error
000015AC  12FC 004D                486      MOVE.B  #'M',(A1)+
000015B0  12FC 004F                487      MOVE.B  #'O',(A1)+
000015B4  12FC 0056                488      MOVE.B  #'V',(A1)+
000015B8  12FC 0045                489      MOVE.B  #'E',(A1)+
000015BC  12FC 004D                490      MOVE.B  #'M',(A1)+
000015C0  12FC 002E                491      MOVE.B  #'.',(A1)+
000015C4  12FC 0057                492      MOVE.B  #'W',(A1)+    
000015C8  13FC 0007 0000252D       493      MOVE.B  #7,char_count                   * Increase character counts
000015D0  4EB9 0000240A            494      JSR     get_space                       * Get more spaces for alignment   
000015D6  6000 00D4                495      BRA     reg_to_mem 
000015DA                           496                         
000015DA                           497  is_MOVEM_long_reg_to_mem
000015DA  B63C 0000                498      CMP.B   #0,D3                           * Check invalid EA mode
000015DE  6700 0C14                499      BEQ     data_error
000015E2  B63C 0001                500      CMP.B   #1,D3                           * Check invalid EA mode
000015E6  6700 0C0C                501      BEQ     data_error
000015EA  B63C 0003                502      CMP.B   #3,D3                           * Check invalid EA mode
000015EE  6700 0C04                503      BEQ     data_error
000015F2  12FC 004D                504      MOVE.B  #'M',(A1)+
000015F6  12FC 004F                505      MOVE.B  #'O',(A1)+
000015FA  12FC 0056                506      MOVE.B  #'V',(A1)+
000015FE  12FC 0045                507      MOVE.B  #'E',(A1)+
00001602  12FC 004D                508      MOVE.B  #'M',(A1)+
00001606  12FC 002E                509      MOVE.B  #'.',(A1)+
0000160A  12FC 004C                510      MOVE.B  #'L',(A1)+     
0000160E  13FC 0007 0000252D       511      MOVE.B  #7,char_count                   * Increase character counts
00001616  4EB9 0000240A            512      JSR     get_space                       * Get more spaces for alignment   
0000161C  6000 008E                513      BRA     reg_to_mem
00001620                           514  
00001620                           515  is_MOVEM_word_mem_to_reg
00001620  B63C 0000                516      CMP.B   #0,D3                           * Check invalid EA mode
00001624  6700 0BCE                517      BEQ     data_error
00001628  B63C 0001                518      CMP.B   #1,D3                           * Check invalid EA mode
0000162C  6700 0BC6                519      BEQ     data_error
00001630  B63C 0004                520      CMP.B   #4,D3                           * Check invalid EA mode
00001634  6700 0BBE                521      BEQ     data_error
00001638  12FC 004D                522      MOVE.B  #'M',(A1)+
0000163C  12FC 004F                523      MOVE.B  #'O',(A1)+
00001640  12FC 0056                524      MOVE.B  #'V',(A1)+
00001644  12FC 0045                525      MOVE.B  #'E',(A1)+
00001648  12FC 004D                526      MOVE.B  #'M',(A1)+
0000164C  12FC 002E                527      MOVE.B  #'.',(A1)+
00001650  12FC 0057                528      MOVE.B  #'W',(A1)+     
00001654  13FC 0007 0000252D       529      MOVE.B  #7,char_count                   * Increase character counts
0000165C  4EB9 0000240A            530      JSR     get_space                       * Get more spaces for alignment   
00001662  6000 0088                531      BRA     mem_to_reg
00001666                           532  
00001666                           533  is_MOVEM_long_mem_to_reg
00001666  B63C 0000                534      CMP.B   #0,D3                           * Check invalid EA mode
0000166A  6700 0B88                535      BEQ     data_error
0000166E  B63C 0001                536      CMP.B   #1,D3                           * Check invalid EA mode
00001672  6700 0B80                537      BEQ     data_error
00001676  B63C 0004                538      CMP.B   #4,D3                           * Check invalid EA mode
0000167A  6700 0B78                539      BEQ     data_error
0000167E  12FC 004D                540      MOVE.B  #'M',(A1)+
00001682  12FC 004F                541      MOVE.B  #'O',(A1)+
00001686  12FC 0056                542      MOVE.B  #'V',(A1)+
0000168A  12FC 0045                543      MOVE.B  #'E',(A1)+
0000168E  12FC 004D                544      MOVE.B  #'M',(A1)+
00001692  12FC 002E                545      MOVE.B  #'.',(A1)+
00001696  12FC 004C                546      MOVE.B  #'L',(A1)+    
0000169A  13FC 0007 0000252D       547      MOVE.B  #7,char_count                   * Increase character counts
000016A2  4EB9 0000240A            548      JSR     get_space                       * Get more spaces for alignment    
000016A8  6000 0042                549      BRA     mem_to_reg
000016AC                           550  
000016AC                           551  reg_to_mem
000016AC  B63C 0004                552      CMP.B   #4,D3                           * check for predecrement
000016B0  6700 0032                553      BEQ     reg_to_mem_pre
000016B4  45F9 0000274C            554      LEA     MOVEM_post,A2                   * Not predecrement, then postincrement    
000016BA                           555  
000016BA                           556  reg_to_mem_cont
000016BA  4280                     557      CLR.L   D0
000016BC  301E                     558      MOVE.W  (A6)+,D0                        * Get WORD and advance memory pointer
000016BE  4281                     559      CLR.L   D1
000016C0  123C 000F                560      MOVE.B  #15,D1                          * Counter for 16 bits
000016C4  4287                     561      CLR.L   D7
000016C6  1E3C 001F                562      MOVE.B  #31,D7                          * Counter for getting registers number   
000016CA  4284                     563      CLR.L   D4
000016CC  183C 001E                564      MOVE.B  #30,D4                          * Counter for getting registers letter  
000016D0  4EB9 00001730            565      JSR     MOVEM_mask_loop                 * Get the registers
000016D6  12FC 002C                566      MOVE.B  #',',(A1)+
000016DA  4EB9 000022A4            567      JSR     EAMode                          * Get destination EA
000016E0  6000 F9F0                568      BRA     Print    
000016E4                           569  
000016E4                           570  reg_to_mem_pre
000016E4  45F9 0000276D            571      LEA     MOVEM_pre,A2                    * Load predecrement string to A2
000016EA  60CE                     572      BRA     reg_to_mem_cont    
000016EC                           573  
000016EC                           574  mem_to_reg
000016EC  4285                     575      CLR.L   D5
000016EE  3A1E                     576      MOVE.W  (A6)+,D5                        * Save WORD for registers
000016F0  4EB9 000022A4            577      JSR     EAMode                          * Get destination EA    
000016F6  12FC 002C                578      MOVE.B  #',',(A1)+
000016FA  B63C 0004                579      CMP.B   #4,D3                           * check for predecrement
000016FE  6700 0028                580      BEQ     mem_to_reg_pre
00001702  45F9 0000274C            581      LEA     MOVEM_post,A2                   * Not predecrement, then postincrement    
00001708                           582  
00001708                           583  mem_to_reg_cont    
00001708  4280                     584      CLR.L   D0
0000170A  3005                     585      MOVE.W  D5,D0                           * Get registers WORD
0000170C  4281                     586      CLR.L   D1
0000170E  123C 000F                587      MOVE.B  #15,D1                          * Counter for 16 bits
00001712  4287                     588      CLR.L   D7
00001714  1E3C 001F                589      MOVE.B  #31,D7                          * Counter for getting registers number   
00001718  4284                     590      CLR.L   D4
0000171A  183C 001E                591      MOVE.B  #30,D4                          * Counter for getting registers letter
0000171E  4EB9 00001730            592      JSR     MOVEM_mask_loop                 * Get the registers
00001724  6000 F9AC                593      BRA     Print
00001728                           594  
00001728                           595  mem_to_reg_pre
00001728  45F9 0000276D            596      LEA     MOVEM_pre,A2                    * Load predecrement string to A2
0000172E  60D8                     597      BRA     mem_to_reg_cont  
00001730                           598  
00001730                           599  *////////////////////////////////////////////////////////////////////////////////////////
00001730                           600  *MOVEM_mask_loop: get the corresponding registers in the operand for MOVEM instruction
00001730                           601  *////////////////////////////////////////////////////////////////////////////////////////     
00001730                           602  MOVEM_mask_loop
00001730  4285                     603      CLR.L   D5
00001732  3A00                     604      MOVE.W  D0,D5                           * Copy D0 to D5
00001734  0245 0001                605      ANDI.W  #$0001,D5                       * Get the first bit only
00001738  BA3C 0000                606      CMP.B   #0,D5
0000173C  6600 0014                607      BNE     MOVEM_get_register              * Bit is not 0    
00001740  5547                     608      SUBI    #2,D7                           * Decrease counter for registers number
00001742  5544                     609      SUBI    #2,D4                           * Decrease counter for registers letter   
00001744                           610     
00001744                           611  MOVEM_mask_loop_cont
00001744  E248                     612      LSR.W   #1,D0                           * Shift right by 1 bit
00001746  5341                     613      SUBI    #1,D1                           * Decrease counter    
00001748  0C41 0000                614      CMPI    #0,D1                           * Check counter
0000174C  6CE2                     615      BGE     MOVEM_mask_loop
0000174E  1021                     616      MOVE.B  -(A1),D0                        * Get rid of extra '/'
00001750                           617    
00001750  4E75                     618      RTS
00001752                           619               
00001752                           620  MOVEM_get_register
00001752  12F2 4000                621      MOVE.B  (A2,D4),(A1)+                   * get the register
00001756  5544                     622      SUBI    #2,D4                           * Decrease counter for registers number
00001758  12F2 7000                623      MOVE.B  (A2,D7),(A1)+                   * get the register
0000175C  5547                     624      SUBI    #2,D7                           * Decrease counter for registers letter    
0000175E  12FC 002F                625      MOVE.B  #'/',(A1)+     
00001762  60E0                     626      BRA     MOVEM_mask_loop_cont
00001764                           627  
00001764                           628  *////////////////////////////////////////////////////////////////////////////////////////
00001764                           629  *code0101: ADDQ/SUBQ/Scc/DBcc
00001764                           630  * SUBQ
00001764                           631  *////////////////////////////////////////////////////////////////////////////////////////    
00001764                           632  code0101
00001764  4280                     633      CLR.L   D0
00001766  1004                     634      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001768  E408                     635      LSR.B   #2,D0                           * Shift right 2 bits
0000176A  0200 0001                636      ANDI.B  #$01,D0                         * Mask all bits except first
0000176E  6600 0006                637      BNE     check_SUBQ                      * Not 0, may be SUBQ
00001772                           638      
00001772  6000 0A80                639      BRA     data_error
00001776                           640      
00001776                           641  check_SUBQ
00001776  1004                     642      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001778  0200 0003                643      ANDI.B  #$03,D0                         * Get first 2 bits
0000177C  0C40 0003                644      CMPI    #3,D0                           * Not 3, then SUBQ
00001780  6600 0006                645      BNE     is_SUBQ
00001784                           646  
00001784  6000 0A6E                647      BRA     data_error
00001788                           648  
00001788                           649  is_SUBQ
00001788  12FC 0053                650      MOVE.B  #'S',(A1)+
0000178C  12FC 0055                651      MOVE.B  #'U',(A1)+
00001790  12FC 0042                652      MOVE.B  #'B',(A1)+
00001794  12FC 0051                653      MOVE.B  #'Q',(A1)+
00001798  4EB9 000023C8            654      JSR     get_size                        * Get size
0000179E  13FC 0006 0000252D       655      MOVE.B  #6,char_count                   * Increase character counts
000017A6  4EB9 0000240A            656      JSR     get_space                       * Get more spaces for alignment  
000017AC  12FC 0023                657      MOVE.B  #'#',(A1)+
000017B0  12FC 0024                658      MOVE.B  #'$',(A1)+    
000017B4  4EB9 000017C8            659      JSR     SUBQ_data
000017BA  12FC 002C                660      MOVE.B  #',',(A1)+
000017BE  4EB9 000022A4            661      JSR     EAMode                          * Get EA destination    
000017C4  6000 F90C                662      BRA     Print    
000017C8                           663      
000017C8                           664  SUBQ_data
000017C8  0C45 0000                665      CMPI    #0,D5                           * Compare data to 0
000017CC  6700 000A                666      BEQ     SUBQ_data_zero
000017D0                           667  
000017D0                           668  SUBQ_data_cont    
000017D0  0645 0030                669      ADD     #$30,D5                         *Convert hex number to ASCII
000017D4  12C5                     670      MOVE.B  D5,(A1)+                        *Add to buffer
000017D6  4E75                     671      RTS   
000017D8                           672      
000017D8                           673  SUBQ_data_zero
000017D8  5045                     674      ADDI    #8,D5                           * 0 represents 8
000017DA  60F4                     675      BRA     SUBQ_data_cont
000017DC                           676  
000017DC                           677  *////////////////////////////////////////////////////////////////////////////////////////
000017DC                           678  *code0110: BSR,BRA,Bcc
000017DC                           679  * BRA - BCS - BVC - BGE - BLT
000017DC                           680  *////////////////////////////////////////////////////////////////////////////////////////           
000017DC                           681  code0110
000017DC  4280                     682      CLR.L   D0
000017DE  3039 0000252A            683      MOVE.W  current,D0                      * Copy the WORD data to D0
000017E4  E048                     684      LSR.W   #8,D0                           * Shift right 8 bits
000017E6  0240 000F                685      ANDI.W  #$0F,D0                         * Get bits 8-11
000017EA                           686      
000017EA  B03C 0000                687      CMP.B   #0,D0                           * BRA
000017EE  6700 0026                688      BEQ     is_BRA
000017F2                           689      
000017F2  B03C 0005                690      CMP.B   #5,D0                           * BCS
000017F6  6700 004C                691      BEQ     is_BCS
000017FA                           692  
000017FA  B03C 0008                693      CMP.B   #8,D0                           * BVC
000017FE  6700 0072                694      BEQ     is_BVC    
00001802                           695  
00001802  B03C 000C                696      CMP.B   #12,D0                          * BGE
00001806  6700 0098                697      BEQ     is_BGE
0000180A                           698  
0000180A  B03C 000D                699      CMP.B   #13,D0                          * BLT
0000180E  6700 00BE                700      BEQ     is_BLT
00001812                           701      
00001812  6000 09E0                702      BRA     data_error                      * Other not required instructions
00001816                           703      
00001816                           704  is_BRA
00001816  12FC 0042                705      MOVE.B  #'B',(A1)+
0000181A  12FC 0052                706      MOVE.B  #'R',(A1)+
0000181E  12FC 0041                707      MOVE.B  #'A',(A1)+
00001822  13FC 0003 0000252D       708      MOVE.B  #3,char_count                   * Increase character counts
0000182A  4EB9 0000240A            709      JSR     get_space                       * Get more spaces for alignment
00001830  4EB9 000018FC            710      JSR     displacement_check
00001836  12FC 0024                711      MOVE.B  #'$',(A1)+     
0000183A  4EB9 000024C8            712      JSR     hex_to_ascii                    * get the displacement        
00001840  6000 F890                713      BRA     Print
00001844                           714  
00001844                           715  is_BCS
00001844  12FC 0042                716      MOVE.B  #'B',(A1)+
00001848  12FC 0043                717      MOVE.B  #'C',(A1)+
0000184C  12FC 0053                718      MOVE.B  #'S',(A1)+
00001850  13FC 0003 0000252D       719      MOVE.B  #3,char_count                   * Increase character counts
00001858  4EB9 0000240A            720      JSR     get_space                       * Get more spaces for alignment     
0000185E  4EB9 000018FC            721      JSR     displacement_check
00001864  12FC 0024                722      MOVE.B  #'$',(A1)+     
00001868  4EB9 000024C8            723      JSR     hex_to_ascii                    * get the displacement  
0000186E  6000 F862                724      BRA     Print
00001872                           725  
00001872                           726  is_BVC
00001872  12FC 0042                727      MOVE.B  #'B',(A1)+
00001876  12FC 0056                728      MOVE.B  #'V',(A1)+
0000187A  12FC 0043                729      MOVE.B  #'C',(A1)+
0000187E  13FC 0003 0000252D       730      MOVE.B  #3,char_count                   * Increase character counts
00001886  4EB9 0000240A            731      JSR     get_space                       * Get more spaces for alignment     
0000188C  4EB9 000018FC            732      JSR     displacement_check
00001892  12FC 0024                733      MOVE.B  #'$',(A1)+     
00001896  4EB9 000024C8            734      JSR     hex_to_ascii                    * get the displacement  
0000189C  6000 F834                735      BRA     Print
000018A0                           736  
000018A0                           737  is_BGE
000018A0  12FC 0042                738      MOVE.B  #'B',(A1)+
000018A4  12FC 0047                739      MOVE.B  #'G',(A1)+
000018A8  12FC 0045                740      MOVE.B  #'E',(A1)+
000018AC  13FC 0003 0000252D       741      MOVE.B  #3,char_count                   * Increase character counts
000018B4  4EB9 0000240A            742      JSR     get_space                       * Get more spaces for alignment     
000018BA  4EB9 000018FC            743      JSR     displacement_check
000018C0  12FC 0024                744      MOVE.B  #'$',(A1)+     
000018C4  4EB9 000024C8            745      JSR     hex_to_ascii                    * get the displacement  
000018CA  6000 F806                746      BRA     Print
000018CE                           747  
000018CE                           748  is_BLT
000018CE  12FC 0042                749      MOVE.B  #'B',(A1)+
000018D2  12FC 004C                750      MOVE.B  #'L',(A1)+
000018D6  12FC 0054                751      MOVE.B  #'T',(A1)+
000018DA  13FC 0003 0000252D       752      MOVE.B  #3,char_count                   * Increase character counts
000018E2  4EB9 0000240A            753      JSR     get_space                       * Get more spaces for alignment    
000018E8  4EB9 000018FC            754      JSR     displacement_check
000018EE  12FC 0024                755      MOVE.B  #'$',(A1)+    
000018F2  4EB9 000024C8            756      JSR     hex_to_ascii                    * get the displacement  
000018F8  6000 F7D8                757      BRA     Print    
000018FC                           758  
000018FC                           759  
000018FC                           760  *////////////////////////////////////////////////////////////////////////////////////////
000018FC                           761  *displacement_check: check the 8 bits displacement and return value in D1
000018FC                           762  *D1: holds 1, 2, 4 for byte, word, long word displacement respectively
000018FC                           763  *////////////////////////////////////////////////////////////////////////////////////////
000018FC                           764  displacement_check
000018FC  4280                     765      CLR.L   D0
000018FE  4281                     766      CLR.L   D1
00001900  3039 0000252A            767      MOVE.W  current,D0                      * Copy the WORD data to D0    
00001906  0240 00FF                768      ANDI.W  #$FF,D0                         * Get 8 bits displacement
0000190A                           769      
0000190A  B03C 0000                770      CMP.B   #$00,D0                         * 16-bits displacement
0000190E  6700 001E                771      BEQ     displacement_word
00001912                           772      
00001912  B03C 00FF                773      CMP.B   #$FF,D0                         * 32-bits displacement
00001916  6700 0028                774      BEQ     displacement_long
0000191A                           775      
0000191A  6000 0002                776      BRA     displacement_byte               * no need additional data for displacement  
0000191E                           777          
0000191E                           778  displacement_byte
0000191E  260E                     779      MOVE.L  A6,D3                           * Get PC current
00001920  D600                     780      ADD.B   D0,D3                           * Get target address
00001922  4280                     781      CLR.L   D0    
00001924  2003                     782      MOVE.L  D3,D0                           * Copy to D0                              
00001926                           783  
00001926  4281                     784      CLR.L   D1
00001928  123C 0004                785      MOVE.B  #4,D1                           * byte size for address is 4
0000192C  4E75                     786      RTS              
0000192E                           787      
0000192E                           788  displacement_word
0000192E  260E                     789      MOVE.L  A6,D3                           * Get PC current
00001930  301E                     790      MOVE.W  (A6)+,D0                        * Get displacement word from memory  
00001932  D640                     791      ADD.W   D0,D3                           * Get target address
00001934  4280                     792      CLR.L   D0
00001936  2003                     793      MOVE.L  D3,D0                           * Copy to D0                              
00001938                           794  
00001938  4281                     795      CLR.L   D1
0000193A  123C 0004                796      MOVE.B  #4,D1                           * byte size for address is 4  
0000193E  4E75                     797      RTS
00001940                           798      
00001940                           799  displacement_long
00001940  260E                     800      MOVE.L  A6,D3                           * Get PC current
00001942  201E                     801      MOVE.L  (A6)+,D0                        * Get displacement long word from memory
00001944  D680                     802      ADD.L   D0,D3                           * Get target address
00001946  4280                     803      CLR.L   D0    
00001948  2003                     804      MOVE.L  D3,D0                           * Copy to D0                              
0000194A                           805  
0000194A  4281                     806      CLR.L   D1
0000194C  123C 0004                807      MOVE.B  #4,D1                           * byte size for address is 4    
00001950  4E75                     808      RTS 
00001952                           809          
00001952                           810         
00001952                           811  *////////////////////////////////////////////////////////////////////////////////////////
00001952                           812  *code0111: MOVEQ
00001952                           813  *//////////////////////////////////////////////////////////////////////////////////////// 
00001952                           814  code0111
00001952  6000 08A0                815      BRA     data_error                      * Other not required instructions
00001956                           816  
00001956                           817  *////////////////////////////////////////////////////////////////////////////////////////
00001956                           818  *code1000: OR/DIV/SBCD
00001956                           819  * OR - DIVS
00001956                           820  *////////////////////////////////////////////////////////////////////////////////////////     
00001956                           821  code1000
00001956  B83C 0007                822      CMP.B   #7,D4                           * DIVS
0000195A  6700 0026                823      BEQ     is_DIVS
0000195E                           824      
0000195E  B83C 0003                825      CMP.B   #3,D4                           * DIVU
00001962  6700 0890                826      BEQ     data_error                      * Other not required instructions    
00001966                           827      
00001966  4280                     828      CLR.L   D0
00001968  4281                     829      CLR.L   D1
0000196A  3039 0000252A            830      MOVE.W  current,D0                      * Copy the WORD data to D0         
00001970  E848                     831      LSR.W   #4,D0                           * Shift right by 4 bits
00001972  0240 001F                832      ANDI.W  #$1F,D0                         * Get bits 4-8
00001976  B03C 0010                833      CMP.B   #16,D0                          * SBCD
0000197A  6700 0878                834      BEQ     data_error                      * Other not required instructions
0000197E                           835      
0000197E  6000 004C                836      BRA     is_OR                           * instruction should be OR    
00001982                           837  
00001982                           838  is_DIVS
00001982  B63C 0001                839      CMP.B   #1,D3                           * Check invalid EA mode
00001986  6700 086C                840      BEQ     data_error
0000198A  12FC 0044                841      MOVE.B  #'D',(A1)+
0000198E  12FC 0049                842      MOVE.B  #'I',(A1)+
00001992  12FC 0056                843      MOVE.B  #'V',(A1)+
00001996  12FC 0053                844      MOVE.B  #'S',(A1)+
0000199A  12FC 002E                845      MOVE.B  #'.',(A1)+
0000199E  12FC 0057                846      MOVE.B  #'W',(A1)+    
000019A2  13FC 0006 0000252D       847      MOVE.B  #6,char_count                   * Increase character counts
000019AA  4EB9 0000240A            848      JSR     get_space                       * Get more spaces for alignment 
000019B0  103C 0002                849      MOVE.B  #2,D0                           * Byte size is 2    
000019B4  4EB9 000022A4            850      JSR     EAMode                          * Get source EA
000019BA  12FC 002C                851      MOVE.B  #',',(A1)+
000019BE  12FC 0044                852      MOVE.B  #'D',(A1)+                  
000019C2  0645 0030                853      ADD     #$30,D5                         *Convert REG# to ASCII
000019C6  12C5                     854      MOVE.B  D5,(A1)+                        *Add to buffer
000019C8  6000 F708                855      BRA     Print         
000019CC                           856  
000019CC                           857  is_OR
000019CC  12FC 004F                858      MOVE.B  #'O',(A1)+
000019D0  12FC 0052                859      MOVE.B  #'R',(A1)+
000019D4  4280                     860      CLR.L   D0
000019D6  4281                     861      CLR.L   D1
000019D8  1004                     862      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
000019DA  0200 0003                863      ANDI.B  #$03,D0                         * Get bits 6-7
000019DE  4EB9 000023C8            864      JSR     get_size                        * Get the size
000019E4  13FC 0004 0000252D       865      MOVE.B  #4,char_count                   * Increase character counts
000019EC  4EB9 0000240A            866      JSR     get_space                       * Get more spaces for alignment    
000019F2  1204                     867      MOVE.B  D4,D1                           * Copy bits 6-8 to D1
000019F4  0201 0004                868      ANDI.B  #$04,D1                         * Get bits 8
000019F8  B23C 0000                869      CMP.B   #0,D1                           * if 0
000019FC  6700 0006                870      BEQ     OR_ea_to_Dn
00001A00                           871  
00001A00  6000 0022                872      BRA     OR_Dn_to_ea    
00001A04                           873          
00001A04                           874  OR_ea_to_Dn
00001A04  B63C 0001                875      CMP.B   #1,D3                           * Check invalid EA mode
00001A08  6700 07EA                876      BEQ     data_error
00001A0C  4EB9 000022A4            877      JSR     EAMode                          * get source EA
00001A12  12FC 002C                878      MOVE.B  #',',(A1)+
00001A16  12FC 0044                879      MOVE.B  #'D',(A1)+                  
00001A1A  0645 0030                880      ADD     #$30,D5                         *Convert REG# to ASCII
00001A1E  12C5                     881      MOVE.B  D5,(A1)+                        *Add to buffer        
00001A20  6000 F6B0                882      BRA     Print
00001A24                           883  
00001A24                           884  OR_Dn_to_ea
00001A24  B63C 0000                885      CMP.B   #0,D3                           * Check invalid EA mode
00001A28  6700 07CA                886      BEQ     data_error
00001A2C  B63C 0001                887      CMP.B   #1,D3                           * Check invalid EA mode
00001A30  6700 07C2                888      BEQ     data_error    
00001A34  12FC 0044                889      MOVE.B  #'D',(A1)+                  
00001A38  0645 0030                890      ADD     #$30,D5                         *Convert REG# to ASCII
00001A3C  12C5                     891      MOVE.B  D5,(A1)+                        *Add to buffer           
00001A3E  12FC 002C                892      MOVE.B  #',',(A1)+
00001A42  4EB9 000022A4            893      JSR     EAMode                          * get source EA
00001A48  6000 F688                894      BRA     Print
00001A4C                           895      
00001A4C                           896  *////////////////////////////////////////////////////////////////////////////////////////
00001A4C                           897  *code1001: SUB/SUBX
00001A4C                           898  * SUB
00001A4C                           899  *////////////////////////////////////////////////////////////////////////////////////////
00001A4C                           900  code1001
00001A4C  4280                     901      CLR.L   D0
00001A4E  1004                     902      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001A50  0200 0003                903      ANDI.B  #$03,D0                         * Get bits 6-7
00001A54  B03C 0003                904      CMP.B   #3,D0                           * SUBA
00001A58  6700 079A                905      BEQ     data_error                      * Other not required instructions
00001A5C                           906  
00001A5C  1004                     907      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001A5E  0200 0004                908      ANDI.B  #$04,D0                         * Get bits 8
00001A62  B03C 0001                909      CMP.B   #1,D0                           * May be SUBX
00001A66  6700 0006                910      BEQ     check_SUBX
00001A6A                           911  
00001A6A  6000 0016                912      BRA     is_SUB     
00001A6E                           913       
00001A6E                           914  check_SUBX
00001A6E  1003                     915      MOVE.B  D3,D0                           * Copy bits 3-5 to D0
00001A70  E208                     916      LSR.B   #1,D0                           * Shift right 1 bit
00001A72  0200 0003                917      ANDI.B  #3,D0                           * Get bits 4-5
00001A76  B038 0000                918      CMP.B   0,D0                            * SUBX
00001A7A  6700 0778                919      BEQ     data_error                      * Other not required instructions
00001A7E                           920  
00001A7E  6000 0002                921      BRA     is_SUB                          * Instruction should be SUB
00001A82                           922  
00001A82                           923  is_SUB
00001A82  12FC 0053                924      MOVE.B  #'S',(A1)+
00001A86  12FC 0055                925      MOVE.B  #'U',(A1)+
00001A8A  12FC 0042                926      MOVE.B  #'B',(A1)+    
00001A8E  4280                     927      CLR.L   D0
00001A90  4281                     928      CLR.L   D1
00001A92  1004                     929      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001A94  0200 0003                930      ANDI.B  #$03,D0                         * Get bits 6-7
00001A98  4EB9 000023C8            931      JSR     get_size                        * Get the size
00001A9E  13FC 0005 0000252D       932      MOVE.B  #5,char_count                   * Increase character counts
00001AA6  4EB9 0000240A            933      JSR     get_space                       * Get more spaces for alignment   
00001AAC  1204                     934      MOVE.B  D4,D1                           * Copy bits 6-8 to D1
00001AAE  0201 0004                935      ANDI.B  #$04,D1                         * Get bits 8
00001AB2  B23C 0000                936      CMP.B   #0,D1                           * if 0
00001AB6  6700 0006                937      BEQ     SUB_ea_to_Dn
00001ABA                           938  
00001ABA  6000 001A                939      BRA     SUB_Dn_to_ea                              
00001ABE                           940  
00001ABE                           941  SUB_ea_to_Dn
00001ABE  4EB9 000022A4            942      JSR     EAMode                          * get source EA
00001AC4  12FC 002C                943      MOVE.B  #',',(A1)+
00001AC8  12FC 0044                944      MOVE.B  #'D',(A1)+                  
00001ACC  0645 0030                945      ADD     #$30,D5                         *Convert REG# to ASCII
00001AD0  12C5                     946      MOVE.B  D5,(A1)+                        *Add to buffer        
00001AD2  6000 F5FE                947      BRA     Print
00001AD6                           948  
00001AD6                           949  SUB_Dn_to_ea
00001AD6  B63C 0000                950      CMP.B   #0,D3                           * Check invalid EA mode
00001ADA  6700 0718                951      BEQ     data_error
00001ADE  B63C 0001                952      CMP.B   #1,D3                           * Check invalid EA mode
00001AE2  6700 0710                953      BEQ     data_error
00001AE6  12FC 0044                954      MOVE.B  #'D',(A1)+                  
00001AEA  0645 0030                955      ADD     #$30,D5                         *Convert REG# to ASCII
00001AEE  12C5                     956      MOVE.B  D5,(A1)+                        *Add to buffer           
00001AF0  12FC 002C                957      MOVE.B  #',',(A1)+
00001AF4  4EB9 000022A4            958      JSR     EAMode                          * get source EA
00001AFA  6000 F5D6                959      BRA     Print
00001AFE                           960  
00001AFE                           961  
00001AFE                           962  *////////////////////////////////////////////////////////////////////////////////////////
00001AFE                           963  *code1010: Unassigned
00001AFE                           964  *////////////////////////////////////////////////////////////////////////////////////////
00001AFE                           965  code1010
00001AFE  6000 06F4                966      BRA     data_error                      * Other not required instructions
00001B02                           967  
00001B02                           968  
00001B02                           969  *////////////////////////////////////////////////////////////////////////////////////////
00001B02                           970  *code1011: CMP/EOR
00001B02                           971  * CMP - EOR
00001B02                           972  *////////////////////////////////////////////////////////////////////////////////////////
00001B02                           973  code1011
00001B02  4280                     974      CLR.L   D0
00001B04  1004                     975      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001B06  E408                     976      LSR.B   #2,D0                           * Get bit 8
00001B08  0C00 0000                977      CMPI.B  #0,D0                           * May be CMP / CMPA
00001B0C  6700 000E                978      BEQ     CMPA_check
00001B10                           979      
00001B10  B63C 0001                980      CMP.B   #1,D3                           * CMPM
00001B14  6700 06DE                981      BEQ     data_error                      * Other not required instructions
00001B18                           982      
00001B18  6000 0056                983      BRA     is_EOR                          * instruction should be EOR
00001B1C                           984      
00001B1C                           985  CMPA_check
00001B1C  1004                     986      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001B1E  0200 0003                987      ANDI.B  #$03,D0                         * Get bits 6-7
00001B22  0C00 0003                988      CMPI.B  #3,D0                           * CMPA
00001B26  6700 06CC                989      BEQ     data_error                      * Other not required instructions
00001B2A  6000 0002                990      BRA     is_CMP                          * instruction should be CMP
00001B2E                           991  
00001B2E                           992  is_CMP
00001B2E  12FC 0043                993      MOVE.B  #'C',(A1)+
00001B32  12FC 004D                994      MOVE.B  #'M',(A1)+
00001B36  12FC 0050                995      MOVE.B  #'P',(A1)+    
00001B3A  4280                     996      CLR.L   D0
00001B3C  4281                     997      CLR.L   D1
00001B3E  1004                     998      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001B40  0200 0003                999      ANDI.B  #$03,D0                         * Get bits 6-7
00001B44  4EB9 000023C8           1000      JSR     get_size                        * Get the size
00001B4A  13FC 0005 0000252D      1001      MOVE.B  #5,char_count                   * Increase character counts
00001B52  4EB9 0000240A           1002      JSR     get_space                       * Get more spaces for alignment  
00001B58  4EB9 000022A4           1003      JSR     EAMode                          * get source EA
00001B5E  12FC 002C               1004      MOVE.B  #',',(A1)+
00001B62  12FC 0044               1005      MOVE.B  #'D',(A1)+                  
00001B66  0645 0030               1006      ADD     #$30,D5                         *Convert REG# to ASCII
00001B6A  12C5                    1007      MOVE.B  D5,(A1)+                        *Add to buffer        
00001B6C  6000 F564               1008      BRA     Print    
00001B70                          1009            
00001B70                          1010  is_EOR
00001B70  B63C 0001               1011      CMP.B   #1,D3                           * Check invalid EA mode
00001B74  6700 067E               1012      BEQ     data_error
00001B78  12FC 0045               1013      MOVE.B  #'E',(A1)+
00001B7C  12FC 004F               1014      MOVE.B  #'O',(A1)+
00001B80  12FC 0052               1015      MOVE.B  #'R',(A1)+    
00001B84  4280                    1016      CLR.L   D0
00001B86  4281                    1017      CLR.L   D1
00001B88  1004                    1018      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001B8A  0200 0003               1019      ANDI.B  #$03,D0                         * Get bits 6-7
00001B8E  4EB9 000023C8           1020      JSR     get_size                        * Get the size
00001B94  13FC 0005 0000252D      1021      MOVE.B  #5,char_count                   * Increase character counts
00001B9C  4EB9 0000240A           1022      JSR     get_space                       * Get more spaces for alignment   
00001BA2  12FC 0044               1023      MOVE.B  #'D',(A1)+                  
00001BA6  0645 0030               1024      ADD     #$30,D5                         *Convert REG# to ASCII
00001BAA  12C5                    1025      MOVE.B  D5,(A1)+                        *Add to buffer           
00001BAC  12FC 002C               1026      MOVE.B  #',',(A1)+
00001BB0  4EB9 000022A4           1027      JSR     EAMode                          * get destination EA
00001BB6  6000 F51A               1028      BRA     Print    
00001BBA                          1029  
00001BBA                          1030  
00001BBA                          1031  *////////////////////////////////////////////////////////////////////////////////////////
00001BBA                          1032  *code1100: AND/MUL/ABCD/EXG
00001BBA                          1033  * MULS
00001BBA                          1034  *////////////////////////////////////////////////////////////////////////////////////////
00001BBA                          1035  code1100
00001BBA  B83C 0007               1036      CMP.B   #7,D4                           * MULS
00001BBE  6700 0006               1037      BEQ     is_MULS
00001BC2                          1038      
00001BC2  6000 0630               1039      BRA     data_error                      * Other not required instructions
00001BC6                          1040      
00001BC6                          1041  is_MULS
00001BC6  B63C 0001               1042      CMP.B   #1,D3                           * Check invalid EA mode
00001BCA  6700 0628               1043      BEQ     data_error
00001BCE  12FC 004D               1044      MOVE.B  #'M',(A1)+
00001BD2  12FC 0055               1045      MOVE.B  #'U',(A1)+
00001BD6  12FC 004C               1046      MOVE.B  #'L',(A1)+
00001BDA  12FC 0053               1047      MOVE.B  #'S',(A1)+
00001BDE  12FC 002E               1048      MOVE.B  #'.',(A1)+
00001BE2  12FC 0057               1049      MOVE.B  #'W',(A1)+    
00001BE6  13FC 0006 0000252D      1050      MOVE.B  #6,char_count                   * Increase character counts
00001BEE  4EB9 0000240A           1051      JSR     get_space                       * Get more spaces for alignment   
00001BF4  103C 0002               1052      MOVE.B  #2,D0                           * Byte size is 2
00001BF8  4EB9 000022A4           1053      JSR     EAMode                          * Get source EA
00001BFE  12FC 002C               1054      MOVE.B  #',',(A1)+
00001C02  12FC 0044               1055      MOVE.B  #'D',(A1)+                  
00001C06  0645 0030               1056      ADD     #$30,D5                         *Convert REG# to ASCII
00001C0A  12C5                    1057      MOVE.B  D5,(A1)+                        *Add to buffer
00001C0C  6000 F4C4               1058      BRA     Print         
00001C10                          1059  
00001C10                          1060  
00001C10                          1061  *////////////////////////////////////////////////////////////////////////////////////////
00001C10                          1062  *code1101: ADD/ADDA/ADDX
00001C10                          1063  * ADD - ADDA
00001C10                          1064  *////////////////////////////////////////////////////////////////////////////////////////
00001C10                          1065  code1101
00001C10  4280                    1066      CLR.L   D0
00001C12  1004                    1067      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001C14  0200 0003               1068      ANDI.B  #$03,D0                         * Get bits 6-7
00001C18  0C00 0003               1069      CMPI.B  #3,D0                           * ADDA
00001C1C  6700 0022               1070      BEQ     is_ADDA
00001C20                          1071      
00001C20  1004                    1072      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001C22  E408                    1073      LSR.B   #2,D0                           * Get bit 8
00001C24  B03C 0001               1074      CMP.B   #1,D0                           * May be ADDX
00001C28  6700 0006               1075      BEQ     ADDX_check
00001C2C  6000 0070               1076      BRA     is_ADD                          * Instruction should be ADD
00001C30                          1077      
00001C30                          1078  ADDX_check
00001C30  1003                    1079      MOVE.B  D3,D0                           * Copy bits 3-5 to D0
00001C32  E208                    1080      LSR.B   #1,D0                           * Get bits 4-5
00001C34  B03C 0000               1081      CMP.B   #0,D0                           * ADDX
00001C38  6700 05BA               1082      BEQ     data_error                      * Other not required instructions
00001C3C  6000 0060               1083      BRA     is_ADD                          * Instruction should be ADD
00001C40                          1084      
00001C40                          1085  is_ADDA
00001C40  12FC 0041               1086      MOVE.B  #'A',(A1)+
00001C44  12FC 0044               1087      MOVE.B  #'D',(A1)+
00001C48  12FC 0044               1088      MOVE.B  #'D',(A1)+
00001C4C  12FC 0041               1089      MOVE.B  #'A',(A1)+
00001C50  B83C 0003               1090      CMP.B   #3,D4                           * Word operation
00001C54  6700 002C               1091      BEQ     ADDA_Word
00001C58  6000 0036               1092      BRA     ADDA_Long                       * Long operation
00001C5C                          1093  
00001C5C                          1094  ADDA_cont   
00001C5C  13FC 0006 0000252D      1095      MOVE.B  #6,char_count                   * Increase character counts
00001C64  4EB9 0000240A           1096      JSR     get_space                       * Get more spaces for alignment  
00001C6A  4EB9 000022A4           1097      JSR     EAMode                          * Get source EA
00001C70  12FC 002C               1098      MOVE.B  #',',(A1)+
00001C74  12FC 0041               1099      MOVE.B  #'A',(A1)+                  
00001C78  0645 0030               1100      ADD     #$30,D5                         *Convert REG# to ASCII
00001C7C  12C5                    1101      MOVE.B  D5,(A1)+                        *Add to buffer
00001C7E  6000 F452               1102      BRA     Print    
00001C82                          1103  
00001C82                          1104  ADDA_Word
00001C82  12FC 002E               1105      MOVE.B  #'.',(A1)+
00001C86  12FC 0057               1106      MOVE.B  #'W',(A1)+
00001C8A  103C 0002               1107      MOVE.B  #2,D0                           * Byte size is 2
00001C8E  60CC                    1108      BRA     ADDA_cont
00001C90                          1109  
00001C90                          1110  ADDA_Long
00001C90  12FC 002E               1111      MOVE.B  #'.',(A1)+
00001C94  12FC 004C               1112      MOVE.B  #'L',(A1)+
00001C98  103C 0004               1113      MOVE.B  #4,D0                           * Byte size is 4
00001C9C  60BE                    1114      BRA     ADDA_cont         
00001C9E                          1115  
00001C9E                          1116  is_ADD    
00001C9E  12FC 0041               1117      MOVE.B  #'A',(A1)+
00001CA2  12FC 0044               1118      MOVE.B  #'D',(A1)+
00001CA6  12FC 0044               1119      MOVE.B  #'D',(A1)+    
00001CAA  4280                    1120      CLR.L   D0
00001CAC  4281                    1121      CLR.L   D1
00001CAE  1004                    1122      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001CB0  0200 0003               1123      ANDI.B  #$03,D0                         * Get bits 6-7
00001CB4  4EB9 000023C8           1124      JSR     get_size                        * Get the size
00001CBA  13FC 0005 0000252D      1125      MOVE.B  #5,char_count                   * Increase character counts
00001CC2  4EB9 0000240A           1126      JSR     get_space                       * Get more spaces for alignment    
00001CC8  1204                    1127      MOVE.B  D4,D1                           * Copy bits 6-8 to D1
00001CCA  0201 0004               1128      ANDI.B  #$04,D1                         * Get bits 8
00001CCE  B23C 0000               1129      CMP.B   #0,D1                           * if 0
00001CD2  6700 0006               1130      BEQ     ADD_ea_to_Dn
00001CD6                          1131  
00001CD6  6000 001A               1132      BRA     ADD_Dn_to_ea                              
00001CDA                          1133  
00001CDA                          1134  ADD_ea_to_Dn
00001CDA  4EB9 000022A4           1135      JSR     EAMode                          * get source EA
00001CE0  12FC 002C               1136      MOVE.B  #',',(A1)+
00001CE4  12FC 0044               1137      MOVE.B  #'D',(A1)+                  
00001CE8  0645 0030               1138      ADD     #$30,D5                         *Convert REG# to ASCII
00001CEC  12C5                    1139      MOVE.B  D5,(A1)+                        *Add to buffer        
00001CEE  6000 F3E2               1140      BRA     Print
00001CF2                          1141  
00001CF2                          1142  ADD_Dn_to_ea
00001CF2  B63C 0000               1143      CMP.B   #0,D3                           * Check invalid EA mode
00001CF6  6700 04FC               1144      BEQ     data_error
00001CFA  B63C 0001               1145      CMP.B   #1,D3                           * Check invalid EA mode
00001CFE  6700 04F4               1146      BEQ     data_error    
00001D02  12FC 0044               1147      MOVE.B  #'D',(A1)+                  
00001D06  0645 0030               1148      ADD     #$30,D5                         *Convert REG# to ASCII
00001D0A  12C5                    1149      MOVE.B  D5,(A1)+                        *Add to buffer           
00001D0C  12FC 002C               1150      MOVE.B  #',',(A1)+
00001D10  4EB9 000022A4           1151      JSR     EAMode                          * get source EA
00001D16  6000 F3BA               1152      BRA     Print
00001D1A                          1153  
00001D1A                          1154  
00001D1A                          1155  *////////////////////////////////////////////////////////////////////////////////////////
00001D1A                          1156  *code1110: Shift/Rotate
00001D1A                          1157  * LSR - LSL - ASR - ASL - ROR - ROL
00001D1A                          1158  *////////////////////////////////////////////////////////////////////////////////////////
00001D1A                          1159  code1110
00001D1A  4280                    1160      CLR.L   D0
00001D1C  1004                    1161      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001D1E  0200 0003               1162      ANDI.B  #$03,D0                         * Get bits 6-7
00001D22  B03C 0003               1163      CMP.B   #3,D0                           * Memory shift
00001D26  6700 0024               1164      BEQ     memory_shift
00001D2A                          1165      
00001D2A  1003                    1166      MOVE.B  D3,D0                           * Copy bits 3-5 to D0
00001D2C  0200 0003               1167      ANDI.B  #$03,D0                         * Get bits 3-4
00001D30                          1168      
00001D30  B03C 0000               1169      CMP.B   #0,D0                           * ASd register
00001D34  6700 01CA               1170      BEQ     ASd_check_register_shift
00001D38                          1171      
00001D38  B03C 0001               1172      CMP.B   #1,D0                           * LSd register
00001D3C  6700 02B6               1173      BEQ     LSd_check_register_shift
00001D40                          1174  
00001D40  B03C 0003               1175      CMP.B   #3,D0                           * ROd register
00001D44  6700 03A2               1176      BEQ     ROd_check_register_shift 
00001D48                          1177  
00001D48  6000 04AA               1178      BRA     data_error                      * Other not required instructions   
00001D4C                          1179  
00001D4C                          1180  memory_shift
00001D4C  BA3C 0000               1181      CMP.B   #0,D5                           * ASd
00001D50  6700 0016               1182      BEQ     ASd_check_memory_shift
00001D54                          1183      
00001D54  BA3C 0001               1184      CMP.B   #1,D5                           * LSd
00001D58  6700 0096               1185      BEQ     LSd_check_memory_shift
00001D5C                          1186  
00001D5C  BA3C 0003               1187      CMP.B   #3,D5                           * ROd
00001D60  6700 0116               1188      BEQ     ROd_check_memory_shift 
00001D64                          1189  
00001D64  6000 048E               1190      BRA     data_error                      * Other not required instructions
00001D68                          1191      
00001D68                          1192  ASd_check_memory_shift
00001D68  1004                    1193      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001D6A  E408                    1194      LSR.B   #2,D0                           * Get bit 8
00001D6C  B03C 0000               1195      CMP.B   #0,D0                           * ASR
00001D70  6700 0006               1196      BEQ     ASR_memory_shift
00001D74  6000 003E               1197      BRA     ASL_memory_shift
00001D78                          1198  
00001D78                          1199  ASR_memory_shift
00001D78  B63C 0000               1200      CMP.B   #0,D3                           * Check invalid EA mode
00001D7C  6700 0476               1201      BEQ     data_error
00001D80  B63C 0001               1202      CMP.B   #1,D3                           * Check invalid EA mode
00001D84  6700 046E               1203      BEQ     data_error    
00001D88  12FC 0041               1204      MOVE.B  #'A',(A1)+
00001D8C  12FC 0053               1205      MOVE.B  #'S',(A1)+
00001D90  12FC 0052               1206      MOVE.B  #'R',(A1)+
00001D94  12FC 002E               1207      MOVE.B  #'.',(A1)+
00001D98  12FC 0057               1208      MOVE.B  #'W',(A1)+
00001D9C  13FC 0005 0000252D      1209      MOVE.B  #5,char_count                   * Increase character counts
00001DA4  4EB9 0000240A           1210      JSR     get_space                       * Get more spaces for alignment
00001DAA  4EB9 000022A4           1211      JSR     EAMode                          * Get EA source
00001DB0  6000 F320               1212      BRA     Print            
00001DB4                          1213  
00001DB4                          1214  ASL_memory_shift
00001DB4  B63C 0000               1215      CMP.B   #0,D3                           * Check invalid EA mode
00001DB8  6700 043A               1216      BEQ     data_error
00001DBC  B63C 0001               1217      CMP.B   #1,D3                           * Check invalid EA mode
00001DC0  6700 0432               1218      BEQ     data_error  
00001DC4  12FC 0041               1219      MOVE.B  #'A',(A1)+
00001DC8  12FC 0053               1220      MOVE.B  #'S',(A1)+
00001DCC  12FC 004C               1221      MOVE.B  #'L',(A1)+
00001DD0  12FC 002E               1222      MOVE.B  #'.',(A1)+
00001DD4  12FC 0057               1223      MOVE.B  #'W',(A1)+
00001DD8  13FC 0005 0000252D      1224      MOVE.B  #5,char_count                   * Increase character counts
00001DE0  4EB9 0000240A           1225      JSR     get_space                       * Get more spaces for alignment
00001DE6  4EB9 000022A4           1226      JSR     EAMode                          * Get EA source
00001DEC  6000 F2E4               1227      BRA     Print        
00001DF0                          1228  
00001DF0                          1229  LSd_check_memory_shift
00001DF0  1004                    1230      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001DF2  E408                    1231      LSR.B   #2,D0                           * Get bit 8
00001DF4  B03C 0000               1232      CMP.B   #0,D0                           * LSR
00001DF8  6700 0006               1233      BEQ     LSR_memory_shift
00001DFC  6000 003E               1234      BRA     LSL_memory_shift
00001E00                          1235  
00001E00                          1236  LSR_memory_shift
00001E00  B63C 0000               1237      CMP.B   #0,D3                           * Check invalid EA mode
00001E04  6700 03EE               1238      BEQ     data_error
00001E08  B63C 0001               1239      CMP.B   #1,D3                           * Check invalid EA mode
00001E0C  6700 03E6               1240      BEQ     data_error  
00001E10  12FC 004C               1241      MOVE.B  #'L',(A1)+
00001E14  12FC 0053               1242      MOVE.B  #'S',(A1)+
00001E18  12FC 0052               1243      MOVE.B  #'R',(A1)+
00001E1C  12FC 002E               1244      MOVE.B  #'.',(A1)+
00001E20  12FC 0057               1245      MOVE.B  #'W',(A1)+
00001E24  13FC 0005 0000252D      1246      MOVE.B  #5,char_count                   * Increase character counts
00001E2C  4EB9 0000240A           1247      JSR     get_space                       * Get more spaces for alignment 
00001E32  4EB9 000022A4           1248      JSR     EAMode                          * Get EA source
00001E38  6000 F298               1249      BRA     Print            
00001E3C                          1250  
00001E3C                          1251  LSL_memory_shift
00001E3C  B63C 0000               1252      CMP.B   #0,D3                           * Check invalid EA mode
00001E40  6700 03B2               1253      BEQ     data_error
00001E44  B63C 0001               1254      CMP.B   #1,D3                           * Check invalid EA mode
00001E48  6700 03AA               1255      BEQ     data_error  
00001E4C  12FC 004C               1256      MOVE.B  #'L',(A1)+
00001E50  12FC 0053               1257      MOVE.B  #'S',(A1)+
00001E54  12FC 004C               1258      MOVE.B  #'L',(A1)+
00001E58  12FC 002E               1259      MOVE.B  #'.',(A1)+
00001E5C  12FC 0057               1260      MOVE.B  #'W',(A1)+
00001E60  13FC 0005 0000252D      1261      MOVE.B  #5,char_count                   * Increase character counts
00001E68  4EB9 0000240A           1262      JSR     get_space                       * Get more spaces for alignment 
00001E6E  4EB9 000022A4           1263      JSR     EAMode                          * Get EA source
00001E74  6000 F25C               1264      BRA     Print
00001E78                          1265  
00001E78                          1266  ROd_check_memory_shift
00001E78  1004                    1267      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001E7A  E408                    1268      LSR.B   #2,D0                           * Get bit 8
00001E7C  B03C 0000               1269      CMP.B   #0,D0                           * ROR
00001E80  6700 0006               1270      BEQ     ROR_memory_shift
00001E84  6000 003E               1271      BRA     ROL_memory_shift
00001E88                          1272  
00001E88                          1273  ROR_memory_shift
00001E88  B63C 0000               1274      CMP.B   #0,D3                           * Check invalid EA mode
00001E8C  6700 0366               1275      BEQ     data_error
00001E90  B63C 0001               1276      CMP.B   #1,D3                           * Check invalid EA mode
00001E94  6700 035E               1277      BEQ     data_error  
00001E98  12FC 0052               1278      MOVE.B  #'R',(A1)+
00001E9C  12FC 004F               1279      MOVE.B  #'O',(A1)+
00001EA0  12FC 0052               1280      MOVE.B  #'R',(A1)+
00001EA4  12FC 002E               1281      MOVE.B  #'.',(A1)+
00001EA8  12FC 0057               1282      MOVE.B  #'W',(A1)+
00001EAC  13FC 0005 0000252D      1283      MOVE.B  #5,char_count                   * Increase character counts
00001EB4  4EB9 0000240A           1284      JSR     get_space                       * Get more spaces for alignment 
00001EBA  4EB9 000022A4           1285      JSR     EAMode                          * Get EA source
00001EC0  6000 F210               1286      BRA     Print            
00001EC4                          1287  
00001EC4                          1288  ROL_memory_shift
00001EC4  B63C 0000               1289      CMP.B   #0,D3                           * Check invalid EA mode
00001EC8  6700 032A               1290      BEQ     data_error
00001ECC  B63C 0001               1291      CMP.B   #1,D3                           * Check invalid EA mode
00001ED0  6700 0322               1292      BEQ     data_error  
00001ED4  12FC 0052               1293      MOVE.B  #'R',(A1)+
00001ED8  12FC 004F               1294      MOVE.B  #'O',(A1)+
00001EDC  12FC 004C               1295      MOVE.B  #'L',(A1)+
00001EE0  12FC 002E               1296      MOVE.B  #'.',(A1)+
00001EE4  12FC 0057               1297      MOVE.B  #'W',(A1)+
00001EE8  13FC 0005 0000252D      1298      MOVE.B  #5,char_count                   * Increase character counts
00001EF0  4EB9 0000240A           1299      JSR     get_space                       * Get more spaces for alignment    
00001EF6  4EB9 000022A4           1300      JSR     EAMode                          * Get EA source
00001EFC  6000 F1D4               1301      BRA     Print  
00001F00                          1302  
00001F00                          1303  ASd_check_register_shift
00001F00  1004                    1304      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001F02  E408                    1305      LSR.B   #2,D0                           * Get bit 8
00001F04  B03C 0000               1306      CMP.B   #0,D0                           * ASR
00001F08  6700 0006               1307      BEQ     ASR_register_shift
00001F0C  6000 0074               1308      BRA     ASL_register_shift
00001F10                          1309      
00001F10                          1310  ASR_register_shift
00001F10  12FC 0041               1311      MOVE.B  #'A',(A1)+
00001F14  12FC 0053               1312      MOVE.B  #'S',(A1)+
00001F18  12FC 0052               1313      MOVE.B  #'R',(A1)+
00001F1C  1004                    1314      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001F1E  0200 0003               1315      ANDI.B  #$03,D0                         * Get bits 6-7
00001F22  4EB9 000023C8           1316      JSR     get_size                        * Get the size
00001F28  13FC 0005 0000252D      1317      MOVE.B  #5,char_count                   * Increase character counts
00001F30  4EB9 0000240A           1318      JSR     get_space                       * Get more spaces for alignment    
00001F36  1003                    1319      MOVE.B  D3,D0                           * Copy bits 3-5 to D0
00001F38  E408                    1320      LSR.B   #2,D0                           * Shift right 2 bits
00001F3A  B03C 0000               1321      CMP.B   #0,D0                           * Immediate
00001F3E  6600 0006               1322      BNE     ASR_register_shift_register
00001F42  6000 001E               1323      BRA     ASR_register_shift_immediate
00001F46                          1324  
00001F46                          1325  ASR_register_shift_register
00001F46  12FC 0044               1326      MOVE.B  #'D',(A1)+                  
00001F4A  0645 0030               1327      ADD     #$30,D5                         *Convert REG# to ASCII
00001F4E  12C5                    1328      MOVE.B  D5,(A1)+                        *Add to buffer           
00001F50  12FC 002C               1329      MOVE.B  #',',(A1)+
00001F54  12FC 0044               1330      MOVE.B  #'D',(A1)+                  
00001F58  0642 0030               1331      ADD     #$30,D2                         *Convert REG# to ASCII
00001F5C  12C2                    1332      MOVE.B  D2,(A1)+                        *Add to buffer     
00001F5E  6000 F172               1333      BRA     Print        
00001F62                          1334  
00001F62                          1335  ASR_register_shift_immediate
00001F62  12FC 0023               1336      MOVE.B  #'#',(A1)+
00001F66  12FC 0024               1337      MOVE.B  #'$',(A1)+
00001F6A  4EB9 000021DC           1338      JSR     shift_immediate_data
00001F70  12FC 002C               1339      MOVE.B  #',',(A1)+
00001F74  12FC 0044               1340      MOVE.B  #'D',(A1)+                  
00001F78  0642 0030               1341      ADD     #$30,D2                         *Convert REG# to ASCII
00001F7C  12C2                    1342      MOVE.B  D2,(A1)+                        *Add to buffer     
00001F7E  6000 F152               1343      BRA     Print    
00001F82                          1344  
00001F82                          1345  ASL_register_shift
00001F82  12FC 0041               1346      MOVE.B  #'A',(A1)+
00001F86  12FC 0053               1347      MOVE.B  #'S',(A1)+
00001F8A  12FC 004C               1348      MOVE.B  #'L',(A1)+
00001F8E  1004                    1349      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001F90  0200 0003               1350      ANDI.B  #$03,D0                         * Get bits 6-7
00001F94  4EB9 000023C8           1351      JSR     get_size                        * Get the size
00001F9A  13FC 0005 0000252D      1352      MOVE.B  #5,char_count                   * Increase character counts
00001FA2  4EB9 0000240A           1353      JSR     get_space                       * Get more spaces for alignment    
00001FA8  1003                    1354      MOVE.B  D3,D0                           * Copy bits 3-5 to D0
00001FAA  E408                    1355      LSR.B   #2,D0                           * Shift right 2 bits
00001FAC  B03C 0000               1356      CMP.B   #0,D0                           * Immediate
00001FB0  6600 0006               1357      BNE     ASL_register_shift_register
00001FB4  6000 001E               1358      BRA     ASL_register_shift_immediate
00001FB8                          1359  
00001FB8                          1360  ASL_register_shift_register
00001FB8  12FC 0044               1361      MOVE.B  #'D',(A1)+                  
00001FBC  0645 0030               1362      ADD     #$30,D5                         *Convert REG# to ASCII
00001FC0  12C5                    1363      MOVE.B  D5,(A1)+                        *Add to buffer           
00001FC2  12FC 002C               1364      MOVE.B  #',',(A1)+
00001FC6  12FC 0044               1365      MOVE.B  #'D',(A1)+                  
00001FCA  0642 0030               1366      ADD     #$30,D2                         *Convert REG# to ASCII
00001FCE  12C2                    1367      MOVE.B  D2,(A1)+                        *Add to buffer     
00001FD0  6000 F100               1368      BRA     Print        
00001FD4                          1369  
00001FD4                          1370  ASL_register_shift_immediate
00001FD4  12FC 0023               1371      MOVE.B  #'#',(A1)+
00001FD8  12FC 0024               1372      MOVE.B  #'$',(A1)+
00001FDC  4EB9 000021DC           1373      JSR     shift_immediate_data
00001FE2  12FC 002C               1374      MOVE.B  #',',(A1)+
00001FE6  12FC 0044               1375      MOVE.B  #'D',(A1)+                  
00001FEA  0642 0030               1376      ADD     #$30,D2                         *Convert REG# to ASCII
00001FEE  12C2                    1377      MOVE.B  D2,(A1)+                        *Add to buffer     
00001FF0  6000 F0E0               1378      BRA     Print    
00001FF4                          1379  
00001FF4                          1380  LSd_check_register_shift
00001FF4  1004                    1381      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00001FF6  E408                    1382      LSR.B   #2,D0                           * Get bit 8
00001FF8  B03C 0000               1383      CMP.B   #0,D0                           * LSR
00001FFC  6700 0006               1384      BEQ     LSR_register_shift
00002000  6000 0074               1385      BRA     LSL_register_shift
00002004                          1386      
00002004                          1387  LSR_register_shift
00002004  12FC 004C               1388      MOVE.B  #'L',(A1)+
00002008  12FC 0053               1389      MOVE.B  #'S',(A1)+
0000200C  12FC 0052               1390      MOVE.B  #'R',(A1)+
00002010  1004                    1391      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00002012  0200 0003               1392      ANDI.B  #$03,D0                         * Get bits 6-7
00002016  4EB9 000023C8           1393      JSR     get_size                        * Get the size
0000201C  13FC 0005 0000252D      1394      MOVE.B  #5,char_count                   * Increase character counts
00002024  4EB9 0000240A           1395      JSR     get_space                       * Get more spaces for alignment     
0000202A  1003                    1396      MOVE.B  D3,D0                           * Copy bits 3-5 to D0
0000202C  E408                    1397      LSR.B   #2,D0                           * Shift right 2 bits
0000202E  B03C 0000               1398      CMP.B   #0,D0                           * Immediate
00002032  6600 0006               1399      BNE     LSR_register_shift_register
00002036  6000 001E               1400      BRA     LSR_register_shift_immediate
0000203A                          1401  
0000203A                          1402  LSR_register_shift_register
0000203A  12FC 0044               1403      MOVE.B  #'D',(A1)+                  
0000203E  0645 0030               1404      ADD     #$30,D5                         *Convert REG# to ASCII
00002042  12C5                    1405      MOVE.B  D5,(A1)+                        *Add to buffer           
00002044  12FC 002C               1406      MOVE.B  #',',(A1)+
00002048  12FC 0044               1407      MOVE.B  #'D',(A1)+                  
0000204C  0642 0030               1408      ADD     #$30,D2                         *Convert REG# to ASCII
00002050  12C2                    1409      MOVE.B  D2,(A1)+                        *Add to buffer     
00002052  6000 F07E               1410      BRA     Print        
00002056                          1411  
00002056                          1412  LSR_register_shift_immediate
00002056  12FC 0023               1413      MOVE.B  #'#',(A1)+
0000205A  12FC 0024               1414      MOVE.B  #'$',(A1)+
0000205E  4EB9 000021DC           1415      JSR     shift_immediate_data
00002064  12FC 002C               1416      MOVE.B  #',',(A1)+
00002068  12FC 0044               1417      MOVE.B  #'D',(A1)+                  
0000206C  0642 0030               1418      ADD     #$30,D2                         *Convert REG# to ASCII
00002070  12C2                    1419      MOVE.B  D2,(A1)+                        *Add to buffer     
00002072  6000 F05E               1420      BRA     Print    
00002076                          1421  
00002076                          1422  LSL_register_shift
00002076  12FC 004C               1423      MOVE.B  #'L',(A1)+
0000207A  12FC 0053               1424      MOVE.B  #'S',(A1)+
0000207E  12FC 004C               1425      MOVE.B  #'L',(A1)+
00002082  1004                    1426      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00002084  0200 0003               1427      ANDI.B  #$03,D0                         * Get bits 6-7
00002088  4EB9 000023C8           1428      JSR     get_size                        * Get the size
0000208E  13FC 0005 0000252D      1429      MOVE.B  #5,char_count                   * Increase character counts
00002096  4EB9 0000240A           1430      JSR     get_space                       * Get more spaces for alignment    
0000209C  1003                    1431      MOVE.B  D3,D0                           * Copy bits 3-5 to D0
0000209E  E408                    1432      LSR.B   #2,D0                           * Shift right 2 bits
000020A0  B03C 0000               1433      CMP.B   #0,D0                           * Immediate
000020A4  6600 0006               1434      BNE     LSL_register_shift_register
000020A8  6000 001E               1435      BRA     LSL_register_shift_immediate
000020AC                          1436  
000020AC                          1437  LSL_register_shift_register
000020AC  12FC 0044               1438      MOVE.B  #'D',(A1)+                  
000020B0  0645 0030               1439      ADD     #$30,D5                         *Convert REG# to ASCII
000020B4  12C5                    1440      MOVE.B  D5,(A1)+                        *Add to buffer           
000020B6  12FC 002C               1441      MOVE.B  #',',(A1)+
000020BA  12FC 0044               1442      MOVE.B  #'D',(A1)+                  
000020BE  0642 0030               1443      ADD     #$30,D2                         *Convert REG# to ASCII
000020C2  12C2                    1444      MOVE.B  D2,(A1)+                        *Add to buffer     
000020C4  6000 F00C               1445      BRA     Print        
000020C8                          1446  
000020C8                          1447  LSL_register_shift_immediate
000020C8  12FC 0023               1448      MOVE.B  #'#',(A1)+
000020CC  12FC 0024               1449      MOVE.B  #'$',(A1)+
000020D0  4EB9 000021DC           1450      JSR     shift_immediate_data
000020D6  12FC 002C               1451      MOVE.B  #',',(A1)+
000020DA  12FC 0044               1452      MOVE.B  #'D',(A1)+                  
000020DE  0642 0030               1453      ADD     #$30,D2                         *Convert REG# to ASCII
000020E2  12C2                    1454      MOVE.B  D2,(A1)+                        *Add to buffer     
000020E4  6000 EFEC               1455      BRA     Print    
000020E8                          1456  
000020E8                          1457  ROd_check_register_shift
000020E8  1004                    1458      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
000020EA  E408                    1459      LSR.B   #2,D0                           * Get bit 8
000020EC  B03C 0000               1460      CMP.B   #0,D0                           * ROR
000020F0  6700 0006               1461      BEQ     ROR_register_shift
000020F4  6000 0074               1462      BRA     ROL_register_shift
000020F8                          1463      
000020F8                          1464  ROR_register_shift
000020F8  12FC 0052               1465      MOVE.B  #'R',(A1)+
000020FC  12FC 004F               1466      MOVE.B  #'O',(A1)+
00002100  12FC 0052               1467      MOVE.B  #'R',(A1)+
00002104  1004                    1468      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00002106  0200 0003               1469      ANDI.B  #$03,D0                         * Get bits 6-7
0000210A  4EB9 000023C8           1470      JSR     get_size                        * Get the size
00002110  13FC 0005 0000252D      1471      MOVE.B  #5,char_count                   * Increase character counts
00002118  4EB9 0000240A           1472      JSR     get_space                       * Get more spaces for alignment    
0000211E  1003                    1473      MOVE.B  D3,D0                           * Copy bits 3-5 to D0
00002120  E408                    1474      LSR.B   #2,D0                           * Shift right 2 bits
00002122  B03C 0000               1475      CMP.B   #0,D0                           * Immediate
00002126  6600 0006               1476      BNE     ROR_register_shift_register
0000212A  6000 001E               1477      BRA     ROR_register_shift_immediate
0000212E                          1478  
0000212E                          1479  ROR_register_shift_register
0000212E  12FC 0044               1480      MOVE.B  #'D',(A1)+                  
00002132  0645 0030               1481      ADD     #$30,D5                         *Convert REG# to ASCII
00002136  12C5                    1482      MOVE.B  D5,(A1)+                        *Add to buffer           
00002138  12FC 002C               1483      MOVE.B  #',',(A1)+
0000213C  12FC 0044               1484      MOVE.B  #'D',(A1)+                  
00002140  0642 0030               1485      ADD     #$30,D2                         *Convert REG# to ASCII
00002144  12C2                    1486      MOVE.B  D2,(A1)+                        *Add to buffer     
00002146  6000 EF8A               1487      BRA     Print        
0000214A                          1488  
0000214A                          1489  ROR_register_shift_immediate
0000214A  12FC 0023               1490      MOVE.B  #'#',(A1)+
0000214E  12FC 0024               1491      MOVE.B  #'$',(A1)+
00002152  4EB9 000021DC           1492      JSR     shift_immediate_data
00002158  12FC 002C               1493      MOVE.B  #',',(A1)+
0000215C  12FC 0044               1494      MOVE.B  #'D',(A1)+                  
00002160  0642 0030               1495      ADD     #$30,D2                         *Convert REG# to ASCII
00002164  12C2                    1496      MOVE.B  D2,(A1)+                        *Add to buffer     
00002166  6000 EF6A               1497      BRA     Print    
0000216A                          1498  
0000216A                          1499  ROL_register_shift
0000216A  12FC 0052               1500      MOVE.B  #'R',(A1)+
0000216E  12FC 004F               1501      MOVE.B  #'O',(A1)+
00002172  12FC 004C               1502      MOVE.B  #'L',(A1)+
00002176  1004                    1503      MOVE.B  D4,D0                           * Copy bits 6-8 to D0
00002178  0200 0003               1504      ANDI.B  #$03,D0                         * Get bits 6-7
0000217C  4EB9 000023C8           1505      JSR     get_size                        * Get the size
00002182  13FC 0005 0000252D      1506      MOVE.B  #5,char_count                   * Increase character counts
0000218A  4EB9 0000240A           1507      JSR     get_space                       * Get more spaces for alignment    
00002190  1003                    1508      MOVE.B  D3,D0                           * Copy bits 3-5 to D0
00002192  E408                    1509      LSR.B   #2,D0                           * Shift right 2 bits
00002194  B03C 0000               1510      CMP.B   #0,D0                           * Immediate
00002198  6600 0006               1511      BNE     ROL_register_shift_register
0000219C  6000 001E               1512      BRA     ROL_register_shift_immediate
000021A0                          1513  
000021A0                          1514  ROL_register_shift_register
000021A0  12FC 0044               1515      MOVE.B  #'D',(A1)+                  
000021A4  0645 0030               1516      ADD     #$30,D5                         *Convert REG# to ASCII
000021A8  12C5                    1517      MOVE.B  D5,(A1)+                        *Add to buffer           
000021AA  12FC 002C               1518      MOVE.B  #',',(A1)+
000021AE  12FC 0044               1519      MOVE.B  #'D',(A1)+                  
000021B2  0642 0030               1520      ADD     #$30,D2                         *Convert REG# to ASCII
000021B6  12C2                    1521      MOVE.B  D2,(A1)+                        *Add to buffer     
000021B8  6000 EF18               1522      BRA     Print        
000021BC                          1523  
000021BC                          1524  ROL_register_shift_immediate
000021BC  12FC 0023               1525      MOVE.B  #'#',(A1)+
000021C0  12FC 0024               1526      MOVE.B  #'$',(A1)+
000021C4  4EB9 000021DC           1527      JSR     shift_immediate_data
000021CA  12FC 002C               1528      MOVE.B  #',',(A1)+
000021CE  12FC 0044               1529      MOVE.B  #'D',(A1)+                  
000021D2  0642 0030               1530      ADD     #$30,D2                         *Convert REG# to ASCII
000021D6  12C2                    1531      MOVE.B  D2,(A1)+                        *Add to buffer     
000021D8  6000 EEF8               1532      BRA     Print    
000021DC                          1533      
000021DC                          1534  shift_immediate_data
000021DC  0C45 0000               1535      CMPI    #0,D5                           * Compare data to 0
000021E0  6700 000A               1536      BEQ     shift_immediate_zero
000021E4                          1537  
000021E4                          1538  shift_immediate_cont    
000021E4  0645 0030               1539      ADD     #$30,D5                         *Convert hex number to ASCII
000021E8  12C5                    1540      MOVE.B  D5,(A1)+                        *Add to buffer
000021EA  4E75                    1541      RTS   
000021EC                          1542      
000021EC                          1543  shift_immediate_zero
000021EC  5045                    1544      ADDI    #8,D5                           * 0 represents 8
000021EE  60F4                    1545      BRA     shift_immediate_cont
000021F0                          1546  
000021F0                          1547  
000021F0                          1548  *////////////////////////////////////////////////////////////////////////////////////////
000021F0                          1549  *code1111: Special/Reserved
000021F0                          1550  *////////////////////////////////////////////////////////////////////////////////////////
000021F0                          1551  code1111    
000021F0  6000 0002               1552      BRA     data_error
000021F4                          1553  
000021F4                          1554  
000021F4                          1555  *////////////////////////////////////////////////////////////////////////////////////////
000021F4                          1556  *data_error: current WORD couldn't be decoded, print the WORD data
000021F4                          1557  *//////////////////////////////////////////////////////////////////////////////////////// 
000021F4                          1558  data_error
000021F4  227C 0000265B           1559      MOVE.L  #buffer,A1                      * Set A1 to point to the print buffer
000021FA  12FC 0044               1560      MOVE.B  #'D',(A1)+
000021FE  12FC 0041               1561      MOVE.B  #'A',(A1)+
00002202  12FC 0054               1562      MOVE.B  #'T',(A1)+
00002206  12FC 0041               1563      MOVE.B  #'A',(A1)+
0000220A  13FC 0004 0000252D      1564      MOVE.B  #4,char_count                   * Increase character counts
00002212  4EB9 0000240A           1565      JSR     get_space                       * Get more spaces for alignment                
00002218  4280                    1566      CLR.L   D0
0000221A  3039 0000252A           1567      MOVE.W  current,D0                      * Copy the WORD data to D0
00002220  4281                    1568      CLR.L   D1
00002222  123C 0002               1569      MOVE.B  #2,D1                           * Byte size is 2               
00002226  4EB9 000024C8           1570      JSR     hex_to_ascii
0000222C  6000 EEA4               1571      BRA     Print
00002230                          1572  
00002230                          1573  *////////////////////////////////////////////////////////////////////////////////////////
00002230                          1574  *end_check: Ask the user for rerun the program with new decoding address
00002230                          1575  *////////////////////////////////////////////////////////////////////////////////////////
00002230                          1576  end_check
00002230  4280                    1577      CLR.L   D0                              * Clear all data registers
00002232  4281                    1578      CLR.L   D1
00002234  4282                    1579      CLR.L   D2
00002236  4283                    1580      CLR.L   D3
00002238  4284                    1581      CLR.L   D4
0000223A  4285                    1582      CLR.L   D5
0000223C  4286                    1583      CLR.L   D6
0000223E  4287                    1584      CLR.L   D7
00002240  91C8                    1585      SUBA.L  A0,A0                           * Clear all address registers
00002242  93C9                    1586      SUBA.L  A1,A1  
00002244  95CA                    1587      SUBA.L  A2,A2  
00002246  97CB                    1588      SUBA.L  A3,A3  
00002248  99CC                    1589      SUBA.L  A4,A4  
0000224A  9BCD                    1590      SUBA.L  A5,A5  
0000224C  9DCE                    1591      SUBA.L  A6,A6      
0000224E  43F9 00002633           1592      LEA     empty_line,A1                   * Assign empty line to A1
00002254  103C 000E               1593      MOVE.B  #14,D0                          * Assign prompt task code to D0
00002258  4E4F                    1594      TRAP    #15                             * Display an empty line      
0000225A  43F9 000025D4           1595      LEA     reset_message,A1                * Assign reset message to A1
00002260  103C 000E               1596      MOVE.B  #14,D0                          * Assign prompt task code to D0
00002264  4E4F                    1597      TRAP    #15                             * Display reset message    
00002266  103C 0005               1598      MOVE.B  #5,D0                           * Assign input task code to D0
0000226A  4E4F                    1599      TRAP    #15                             * Read a single character to D1
0000226C  43F9 00002633           1600      LEA     empty_line,A1                   * Assign empty line to A1
00002272  103C 000E               1601      MOVE.B  #14,D0                          * Assign prompt task code to D0
00002276  4E4F                    1602      TRAP    #15                             * Display an empty line
00002278  43F9 00002633           1603      LEA     empty_line,A1                   * Assign empty line to A1
0000227E  103C 000E               1604      MOVE.B  #14,D0                          * Assign prompt task code to D0
00002282  4E4F                    1605      TRAP    #15                             * Display an empty line      
00002284  B23C 0059               1606      CMP.B   #$59,D1                         * is it Y
00002288  6700 ED76               1607      BEQ     start
0000228C  B23C 0079               1608      CMP.B   #$79,D1                         * is it y
00002290  6700 ED6E               1609      BEQ     start    
00002294                          1610            
00002294  43F9 0000306E           1611      LEA     end_message,A1                  * Assign end message to A1
0000229A  103C 000E               1612      MOVE.B  #14,D0                          * Assign prompt task code to D0
0000229E  4E4F                    1613      TRAP    #15                             * Display end message
000022A0  4E72 2700               1614      STOP    #$00002700                      * Stop                
000022A4                          1615  
000022A4                          1616  ***************************************************************************************************
000022A4                          1617  ***************************************************************************************************
000022A4                          1618  *
000022A4                          1619  * SUBROUTINES
000022A4                          1620  *
000022A4                          1621  ***************************************************************************************************
000022A4                          1622  ***************************************************************************************************
000022A4                          1623  
000022A4                          1624  *////////////////////////////////////////////////////////////////////////////////////////
000022A4                          1625  *EAMode: take in the 6 bits EA and branch to the corresponding EA mode
000022A4                          1626  *D0: byte size for immediate data
000022A4                          1627  *D3: the 3 bits EA MODE
000022A4                          1628  *D2: the 3 bits EA REG
000022A4                          1629  *//////////////////////////////////////////////////////////////////////////////////////// 
000022A4                          1630  EAMode
000022A4  B63C 0000               1631      CMP.B   #0,D3
000022A8  6700 003A               1632      BEQ     EAmode0
000022AC  B63C 0001               1633      CMP.B   #1,D3
000022B0  6700 003E               1634      BEQ     EAmode1
000022B4  B63C 0002               1635      CMP.B   #2,D3
000022B8  6700 0042               1636      BEQ     EAmode2
000022BC  B63C 0003               1637      CMP.B   #3,D3
000022C0  6700 004E               1638      BEQ     EAmode3
000022C4  B63C 0004               1639      CMP.B   #4,D3
000022C8  6700 005E               1640      BEQ     EAmode4
000022CC  B63C 0005               1641      CMP.B   #5,D3
000022D0  6700 006E               1642      BEQ     EAmode5
000022D4  B63C 0006               1643      CMP.B   #6,D3
000022D8  6700 0072               1644      BEQ     EAmode6
000022DC  B63C 0007               1645      CMP.B   #7,D3
000022E0  6700 0076               1646      BEQ     EAmode7    
000022E4                          1647        
000022E4                          1648  EAmode0
000022E4  12FC 0044               1649      MOVE.B  #'D',(A1)+                  
000022E8  0642 0030               1650      ADD     #$30,D2                         *Convert REG# to ASCII
000022EC  12C2                    1651      MOVE.B  D2,(A1)+                        *Add to buffer
000022EE                          1652  
000022EE  4E75                    1653      RTS    
000022F0                          1654      
000022F0                          1655  EAmode1
000022F0  12FC 0041               1656      MOVE.B  #'A',(A1)+                  
000022F4  0642 0030               1657      ADD     #$30,D2                         *Convert REG# to ASCII
000022F8  12C2                    1658      MOVE.B  D2,(A1)+                        *Add to buffer
000022FA                          1659      
000022FA  4E75                    1660      RTS
000022FC                          1661  
000022FC                          1662  EAmode2
000022FC  12FC 0028               1663      MOVE.B  #'(',(A1)+
00002300  12FC 0041               1664      MOVE.B  #'A',(A1)+                  
00002304  0642 0030               1665      ADD     #$30,D2                         *Convert REG# to ASCII
00002308  12C2                    1666      MOVE.B  D2,(A1)+                        *Add to buffer
0000230A  12FC 0029               1667      MOVE.B  #')',(A1)+
0000230E                          1668  
0000230E  4E75                    1669      RTS
00002310                          1670  
00002310                          1671  EAmode3
00002310  12FC 0028               1672      MOVE.B  #'(',(A1)+
00002314  12FC 0041               1673      MOVE.B  #'A',(A1)+                  
00002318  0642 0030               1674      ADD     #$30,D2                         *Convert REG# to ASCII
0000231C  12C2                    1675      MOVE.B  D2,(A1)+                        *Add to buffer
0000231E  12FC 0029               1676      MOVE.B  #')',(A1)+
00002322  12FC 002B               1677      MOVE.B  #'+',(A1)+
00002326                          1678  
00002326  4E75                    1679      RTS
00002328                          1680  
00002328                          1681  EAmode4
00002328  12FC 002D               1682      MOVE.B  #'-',(A1)+
0000232C  12FC 0028               1683      MOVE.B  #'(',(A1)+
00002330  12FC 0041               1684      MOVE.B  #'A',(A1)+                  
00002334  0642 0030               1685      ADD     #$30,D2                         *Convert REG# to ASCII
00002338  12C2                    1686      MOVE.B  D2,(A1)+                        *Add to buffer
0000233A  12FC 0029               1687      MOVE.B  #')',(A1)+
0000233E                          1688  
0000233E  4E75                    1689      RTS
00002340                          1690  
00002340                          1691  EAmode5
00002340  227C 0000265B           1692      MOVE.L  #buffer,A1                      * Set A1 to point to the print buffer
00002346  4EB8 21F4               1693      JSR     data_error                      * Invalid EA mode  
0000234A                          1694  
0000234A  4E75                    1695      RTS              
0000234C                          1696   
0000234C                          1697  EAmode6
0000234C  227C 0000265B           1698      MOVE.L  #buffer,A1                      * Set A1 to point to the print buffer
00002352  4EB8 21F4               1699      JSR     data_error                      * Invalid EA mode 
00002356                          1700  
00002356  4E75                    1701      RTS
00002358                          1702  
00002358                          1703  EAmode7
00002358  B43C 0000               1704      CMP.B   #0,D2                           *WORD addressing mode
0000235C  6700 0028               1705      BEQ     get_word  
00002360                          1706    
00002360  B43C 0001               1707      CMP.B   #1,D2                           *LONG WORD addressing mode        
00002364  6700 0036               1708      BEQ     get_long                   
00002368                          1709      
00002368  B43C 0004               1710      CMP.B   #4,D2                           *IMMEDIATE DATA addressing mode
0000236C  6700 0044               1711      BEQ     immediate_data
00002370                          1712  
00002370                          1713  
00002370                          1714  *////////////////////////////////////////////////////////////////////////////////////////
00002370                          1715  *get_byte: get next byte from memory and put in the print buffer
00002370                          1716  *A6: pointer to current memory
00002370                          1717  *A1: pointer to the print buffer
00002370                          1718  *D0: hold the data from memory
00002370                          1719  *D1: hold the size 
00002370                          1720  *////////////////////////////////////////////////////////////////////////////////////////
00002370                          1721  get_byte
00002370  12FC 0024               1722      MOVE.B  #'$',(A1)+    
00002374  4280                    1723      CLR.L   D0                              *Clear D0
00002376  301E                    1724      MOVE.W  (A6)+,D0                        *Get next WORD from memory
00002378  4281                    1725      CLR.L   D1                              *Clear D1
0000237A  123C 0001               1726      MOVE.B  #1,D1                           *Byte size is 1  
0000237E                          1727      
0000237E  4EB9 000024C8           1728      JSR     hex_to_ascii
00002384                          1729      
00002384  4E75                    1730      RTS
00002386                          1731  
00002386                          1732  *////////////////////////////////////////////////////////////////////////////////////////
00002386                          1733  *get_word: get next word from memory and put in the print buffer
00002386                          1734  *A6: pointer to current memory
00002386                          1735  *A1: pointer to the print buffer
00002386                          1736  *D0: hold the data from memory
00002386                          1737  *D1: hold the size 
00002386                          1738  *////////////////////////////////////////////////////////////////////////////////////////
00002386                          1739  get_word
00002386  12FC 0024               1740      MOVE.B  #'$',(A1)+    
0000238A  4280                    1741      CLR.L   D0                              *Clear D0
0000238C  301E                    1742      MOVE.W  (A6)+,D0                        *Get next WORD from memory
0000238E  4281                    1743      CLR.L   D1                              *Clear D1
00002390  123C 0002               1744      MOVE.B  #2,D1                           *Byte size is 2  
00002394                          1745      
00002394  4EB9 000024C8           1746      JSR     hex_to_ascii
0000239A                          1747      
0000239A  4E75                    1748      RTS
0000239C                          1749      
0000239C                          1750  *////////////////////////////////////////////////////////////////////////////////////////
0000239C                          1751  *get_long: get next long word from memory and put in the print buffer
0000239C                          1752  *A6: pointer to current memory
0000239C                          1753  *A1: pointer to the print buffer
0000239C                          1754  *D0: hold the data from memory
0000239C                          1755  *D1: hold the size 
0000239C                          1756  *////////////////////////////////////////////////////////////////////////////////////////    
0000239C                          1757  get_long
0000239C  12FC 0024               1758      MOVE.B  #'$',(A1)+
000023A0  4280                    1759      CLR.L   D0                              *Clear D0
000023A2  201E                    1760      MOVE.L  (A6)+,D0                        *Get next LONG WORD from memory
000023A4  4281                    1761      CLR.L   D1                              *Clear D1
000023A6  123C 0004               1762      MOVE.B  #4,D1                           *Byte size is 4
000023AA                          1763      
000023AA  4EB9 000024C8           1764      JSR     hex_to_ascii 
000023B0                          1765  
000023B0  4E75                    1766      RTS
000023B2                          1767  
000023B2                          1768  *////////////////////////////////////////////////////////////////////////////////////////
000023B2                          1769  *immediate_data: get the immediate data from memory and put in the print buffer
000023B2                          1770  *A1: pointer to the print buffer
000023B2                          1771  *D0: hold the size
000023B2                          1772  *////////////////////////////////////////////////////////////////////////////////////////
000023B2                          1773  immediate_data    
000023B2  12FC 0023               1774      MOVE.B  #'#',(A1)+
000023B6  B03C 0002               1775      CMP.B   #2,D0                           *Is the size WORD
000023BA  67CA                    1776      BEQ     get_word    
000023BC  B03C 0004               1777      CMP.B   #4,D0                           *Is the size LONG WORD
000023C0  67DA                    1778      BEQ     get_long
000023C2  B03C 0001               1779      CMP.B   #1,D0                           *Is the size BYTE
000023C6  67A8                    1780      BEQ     get_byte
000023C8                          1781  
000023C8                          1782  *////////////////////////////////////////////////////////////////////////////////////////
000023C8                          1783  *get_size: take in 2 bits for size and add the corresponding size to the print buffer
000023C8                          1784  *          also return 1, 2, or 4 for byte, word, or long in D0 respectively
000023C8                          1785  *D0: the 2 bits for size
000023C8                          1786  *A1: pointer to the print buffer
000023C8                          1787  *////////////////////////////////////////////////////////////////////////////////////////
000023C8                          1788  get_size
000023C8  B03C 0000               1789      CMP.B   #0,D0
000023CC  6700 0012               1790      BEQ     byte_size
000023D0  B03C 0001               1791      CMP.B   #1,D0
000023D4  6700 0018               1792      BEQ     word_size
000023D8  B03C 0002               1793      CMP.B   #2,D0
000023DC  6700 001E               1794      BEQ     long_size
000023E0                          1795      
000023E0                          1796  byte_size
000023E0  12FC 002E               1797      MOVE.B  #'.',(A1)+
000023E4  12FC 0042               1798      MOVE.B  #'B',(A1)+
000023E8  103C 0001               1799      MOVE.B  #1,D0                           * Put 1 in D0 for 1 byte
000023EC  4E75                    1800      RTS
000023EE                          1801  
000023EE                          1802  word_size
000023EE  12FC 002E               1803      MOVE.B  #'.',(A1)+
000023F2  12FC 0057               1804      MOVE.B  #'W',(A1)+
000023F6  103C 0002               1805      MOVE.B  #2,D0                           * Put 2 in D0 for 2 bytes
000023FA  4E75                    1806      RTS    
000023FC                          1807      
000023FC                          1808  long_size
000023FC  12FC 002E               1809      MOVE.B  #'.',(A1)+
00002400  12FC 004C               1810      MOVE.B  #'L',(A1)+
00002404  103C 0004               1811      MOVE.B  #4,D0                           * Put 4 in D0 for 1 bytes     
00002408  4E75                    1812      RTS     
0000240A                          1813  
0000240A                          1814  *////////////////////////////////////////////////////////////////////////////////////////
0000240A                          1815  *get_space: use for aligning operands
0000240A                          1816  *A1: pointer to the print buffer
0000240A                          1817  *///////////////////////////////////////////////////////////////////////////////////////
0000240A                          1818  get_space
0000240A  0C39 000A 0000252D      1819      CMP.B   #max_char,char_count            * Compare character counts to max_char
00002412  6600 000C               1820      BNE     add_space                       * Add more space if not equal
00002416  13FC 0000 0000252D      1821      MOVE.B  #0,char_count                   * Reset character counts
0000241E  4E75                    1822      RTS    
00002420                          1823      
00002420                          1824  add_space
00002420  12FC 0020               1825      MOVE.B  #' ',(A1)+                      * Add a space
00002424  5239 0000252D           1826      ADD.B   #1,char_count                   * Increase character counts
0000242A  60DE                    1827      BRA     get_space    
0000242C                          1828  
0000242C                          1829  
0000242C                          1830  *////////////////////////////////////////////////////////////////////////////////////////
0000242C                          1831  *ascii_to_hex: transforms ASCII input into a hexadecimal address, 
0000242C                          1832  *              returns error if invalid characters
0000242C                          1833  *D1: ASCII parameter to be converted
0000242C                          1834  *D2: Internal data used for comparison
0000242C                          1835  *D3: Return data
0000242C                          1836  *D6: Internal data used for NULL comparison
0000242C                          1837  *////////////////////////////////////////////////////////////////////////////////////////
0000242C                          1838  ascii_to_hex    
0000242C  7C00                    1839      MOVEQ   #$0,D6                          * Clear D6 for null comparison
0000242E  7600                    1840      MOVEQ   #$0,D3                          * Clear D3 for new data
00002430  B203                    1841      CMP.B   D3,D1                           * Null check on string
00002432  6700 005E               1842      BEQ     bound_error                     * Error if null
00002436  0C41 0000               1843      CMPI    #$0,D1                          * Character check on string
0000243A  6F00 0056               1844      BLE     bound_error                     * Error if less than 0
0000243E  0C41 0008               1845      CMPI    #$8,D1                          * Character check on string
00002442  6E00 004E               1846      BGT     bound_error                     * Error if more than 8 characters
00002446                          1847                  
00002446                          1848  translate       
00002446  1419                    1849      MOVE.B  (A1)+,D2                        * Move next character into D2
00002448  B406                    1850      CMP.B   D6,D2                           * Null check on character
0000244A  6700 0044               1851      BEQ     result                          * End of input if null
0000244E  B43C 0066               1852      CMP.B   #102,D2                         * Compare with 102 (highest character code)
00002452  6E00 003E               1853      BGT     bound_error                     * Error if character is higher than 102
00002456  B43C 0060               1854      CMP.B   #96,D2                          * Compare with 96 (lowest lowercase hex)
0000245A  6E00 0036               1855      BGT     bound_error                     * Error if character is lowercase
0000245E  B43C 0046               1856      CMP.B   #70,D2                          * Compare with 70 (highest uppercase hex)
00002462  6E00 002E               1857      BGT     bound_error                     * Error if character is between 70 and 96
00002466  B43C 0040               1858      CMP.B   #64,D2                          * Compare with 64 (lowest uppercase hex)
0000246A  6E00 001A               1859      BGT     uppercase                       * Branch to uppercase if above 64
0000246E  B43C 0039               1860      CMP.B   #57,D2                          * Compare with 57 (highest decimal number)
00002472  6E00 001E               1861      BGT     bound_error                     * Error if character is between 57 and 64
00002476  B43C 0030               1862      CMP.B   #48,D2                          * Compare with 48 (lowest decimal number)
0000247A  6D00 0016               1863      BLT     bound_error                     * Error if character is below 48
0000247E  0402 0030               1864      SUBI.B  #48,D2                          * Subtract 48 from ASCII value to get hexadecimal value
00002482  6000 0006               1865      BRA     decoded                         * Translation complete
00002486                          1866                  
00002486                          1867  uppercase       
00002486  0402 0037               1868      SUBI.B  #55,D2                          * Subtract 55 from ASCII value to get hexadecimal value
0000248A                          1869  
0000248A                          1870  decoded         
0000248A  E983                    1871      ASL.L   #4,D3                           * Clear the return location
0000248C  D602                    1872      ADD.B   D2,D3                           * Move the resulting character into the return location
0000248E  60B6                    1873      BRA     translate                       * Check next character
00002490                          1874                  
00002490                          1875  result
00002490  4E75                    1876      RTS                                     * Return
00002492                          1877      
00002492                          1878  *////////////////////////////////////////////////////////////////////////////////////////
00002492                          1879  *bound_error: The provided address was out of the valid range, print an error message and ask for
00002492                          1880  * a new one.
00002492                          1881  *////////////////////////////////////////////////////////////////////////////////////////
00002492                          1882  bound_error     
00002492  43F9 00002589           1883      LEA     input_error,A1                  * Assign input error message into A1
00002498  103C 000E               1884      MOVE.B  #14,D0                          * Assign task code for message into D0
0000249C  4E4F                    1885      TRAP    #15                             * Display message
0000249E  4EF8 101A               1886      JMP     get_start                       * Prompt for starting address again
000024A2                          1887      
000024A2                          1888  *////////////////////////////////////////////////////////////////////////////////////////
000024A2                          1889  *even_check: Checks whether an address is even, branches to error message if odd.  
000024A2                          1890  *            (Does not change address if even).
000024A2                          1891  *////////////////////////////////////////////////////////////////////////////////////////
000024A2                          1892  even_check      
000024A2  4282                    1893      CLR.L   D2                              * Clear D2 for new address
000024A4  7202                    1894      MOVE.L  #$00000002,D1                   * Assign value 2 into D1
000024A6  3403                    1895      MOVE.W  D3,D2                           * Move address we want to check into D2
000024A8  84C1                    1896      DIVU    D1,D2                           * Divide the address by 2
000024AA  4842                    1897      SWAP    D2                              * Swap D2 to find the remainder
000024AC  B43C 0001               1898      CMP.B   #$01,D2                         * Check if there is a remainder in D2
000024B0  6700 0004               1899      BEQ     odd_error                       * Branch to error if address is odd
000024B4  4E75                    1900      RTS                                     * Return
000024B6                          1901      
000024B6                          1902  *////////////////////////////////////////////////////////////////////////////////////////
000024B6                          1903  *odd_error: The provided address was odd, so print an error and return a -1 for the address.
000024B6                          1904  *////////////////////////////////////////////////////////////////////////////////////////
000024B6                          1905  odd_error       
000024B6  43F9 000025B4           1906      LEA     not_even,A1                     * Assign odd error message to A1
000024BC  103C 000E               1907      MOVE.B  #14,D0                          * Assign prompt task code to D0
000024C0  4E4F                    1908      TRAP    #15                             * Display odd error message
000024C2  4686                    1909      NOT.L   D6                              * Assign D6's value to be -1
000024C4  2606                    1910      MOVE.L  D6,D3                           * Assign the given address to -1
000024C6  4E75                    1911      RTS                                     * Return
000024C8                          1912      
000024C8                          1913  *////////////////////////////////////////////////////////////////////////////////////////
000024C8                          1914  *hex_to_ascii: Translates a given HEX value to ASCII for printing
000024C8                          1915  *A1: Resulting HEX value
000024C8                          1916  *D0: Value to be converted
000024C8                          1917  *D1: Size - Number of bytes to be converted
000024C8                          1918  *D2: Current character being processed (internal)
000024C8                          1919  *D3: Loop counter
000024C8                          1920  *////////////////////////////////////////////////////////////////////////////////////////
000024C8                          1921  hex_to_ascii    
000024C8  0281 000000FF           1922      ANDI.L  #$000000FF,D1                   * Isolate the size
000024CE  B23C 0004               1923      CMP.B   #4,D1                           * Compare the size to 4
000024D2  6E00 0048               1924      BGT     hta_error                       * Error if the size is > 4
000024D6  B23C 0000               1925      CMP.B   #0,D1                           * Compare the size to 0
000024DA  6F00 0040               1926      BLE     hta_error                       * Error if the size < 0
000024DE  48E7 B000               1927      MOVEM.L D0/D2-D3,-(A7)                  * Push the register data onto the stack
000024E2  E399                    1928      ROL.L   #1,D1                           * Rotate left by 1 to multiply the size by 2
000024E4  2601                    1929      MOVE.L  D1,D3                           * Save the counter into D3
000024E6                          1930                  
000024E6                          1931  hta_loop        
000024E6  2400                    1932      MOVE.L  D0,D2                           * Copy data at D0 into D2
000024E8  0202 000F               1933      ANDI.B  #%00001111,D2                   * Select the first ASCII character in D2
000024EC  B43C 0009               1934      CMP.B   #9,D2                           * Compare the character to 9
000024F0  6F00 000A               1935      BLE     hta_number                      * Branch to hex number if <= 9
000024F4  0642 0037               1936      ADDI    #55,D2                          * If letter, add 55 to make it an ASCII value
000024F8  6000 0006               1937      BRA     hta_continue                    * Branch to stack operation
000024FC                          1938                  
000024FC                          1939  hta_number      
000024FC  0642 0030               1940      ADDI    #48,D2                          * If number, add 48 to make it an ASCII value
00002500                          1941  
00002500                          1942  hta_continue    
00002500  1F02                    1943      MOVE.B  D2,-(A7)                        * Add the ASCII value to the stack
00002502  E898                    1944      ROR.L   #4,D0                           * Rotate right by 4 to get the next character
00002504  5341                    1945      SUBI    #1,D1                           * Subtract 1 from the counter
00002506  B23C 0000               1946      CMP.B   #0,D1                           * Compare the counter to 0
0000250A  66DA                    1947      BNE     hta_loop                        * Branch to convert the next character if counter is not 0
0000250C                          1948                  
0000250C                          1949  hta_result      
0000250C  12DF                    1950      MOVE.B  (A7)+,(A1)+                     * Retrieve ASCII values from the stack and put them in A1
0000250E  5343                    1951      SUBI    #1,D3                           * Subtract 1 from the counter
00002510  B63C 0000               1952      CMP.B   #0,D3                           * Compare the counter to 0
00002514  66F6                    1953      BNE     hta_result                      * Branch to retrieve the next character if counter is not 0
00002516  4CDF 000D               1954      MOVEM.L (A7)+,D0/D2-D3                  * Retrieve original data for the register
0000251A                          1955  
0000251A                          1956  hta_finish      
0000251A  4E75                    1957      RTS                                     * Return
0000251C                          1958      
0000251C                          1959  *////////////////////////////////////////////////////////////////////////////////////////
0000251C                          1960  *odd_error: The provided address was odd, so print an error and return a -1 for the address.
0000251C                          1961  *////////////////////////////////////////////////////////////////////////////////////////
0000251C                          1962  hta_error       
0000251C  43F9 00002637           1963      LEA     hta_error_msg,A1                * Assign hex to ascii error message into A1
00002522  103C 000E               1964      MOVE.B  #14,D0                          * Assign task code for message into D0
00002526  4E4F                    1965      TRAP    #15                             * Display message
00002528  4E75                    1966      RTS                                     * Return
0000252A                          1967      
0000252A                          1968  ***************************************************************************************************
0000252A                          1969  ***************************************************************************************************
0000252A                          1970  *
0000252A                          1971  * VARIABLES
0000252A                          1972  *
0000252A                          1973  ***************************************************************************************************
0000252A                          1974  ***************************************************************************************************
0000252A  =00007000               1975  begin           EQU     $00007000           * Minimum starting
0000252A  =00FFFFFE               1976  end             EQU     $00FFFFFE           * Minimum ending
0000252A  =00007000               1977  stack           EQU     $7000               * Stack address
0000252A  =0000000C               1978  shift           EQU     12                  * Shift 12 bits
0000252A  =0000000D               1979  CR              EQU     $0D                 * ASCII code for Carriage Return
0000252A  =0000000A               1980  LF              EQU     $0A                 * ASCII code for Line Feed
0000252A  =00000014               1981  max_line        EQU     20                  * How many lines to display per screen
0000252A  =0000000A               1982  max_char        EQU     10                  * How many characters between instruction and operands
0000252A= 0001                    1983  current         DC.W    1                   * Store the current WORD
0000252C= 01                      1984  line_count      DC.B    1                   * Store the current screen line count
0000252D= 01                      1985  char_count      DC.B    1                   * Store the instruction characters count    
0000252E= 45 6E 74 65 72 20 ...   1986  start_prompt    DC.B    'Enter starting address: ($7000 to $00FFFFFE)',CR,LF,0
0000255D= 45 6E 74 65 72 20 ...   1987  end_prompt      DC.B    'Enter ending address: (start to $00FFFFE)',CR,LF,0
00002589= 54 68 65 72 65 20 ...   1988  input_error     DC.B    'There was something wrong with the input',CR,LF,0
000025B4= 54 68 65 20 73 70 ...   1989  not_even        DC.B    'The specified address was odd',CR,LF,0
000025D4= 44 6F 20 79 6F 75 ...   1990  reset_message   DC.B    'Do you want to run the program again? (Enter Y or y to run again)',CR,LF,0
00002618= 50 72 65 73 73 20 ...   1991  screen_enter    DC.B    'Press Enter to continue!',CR,LF,0
00002633= 20 0D 0A 00             1992  empty_line      DC.B    ' ',CR,LF,0
00002637= 54 68 65 20 6E 75 ...   1993  hta_error_msg   DC.B    'The number of bytes was incorrect',CR,LF,0
0000265B                          1994  buffer          DS.B    80
000026AB                          1995  start_input     DS.B    80
000026FB                          1996  end_input       DS.B    80
0000274B                          1997  discard         DS.B    1
0000274C= 41 37 41 36 41 35 ...   1998  MOVEM_post      DC.B    'A7','A6','A5','A4','A3','A2','A1','A0','D7','D6','D5','D4','D3','D2','D1','D0',0
0000276D= 44 30 44 31 44 32 ...   1999  MOVEM_pre       DC.B    'D0','D1','D2','D3','D4','D5','D6','D7','A0','A1','A2','A3','A4','A5','A6','A7',0
0000278E= 57 65 6C 63 6F 6D ...   2000  greeting        DC.B    'Welcome to EASY68K Disassembler by Team FIREBALL!',CR,LF
000027C1= 20 0D 0A                2001                  DC.B    ' ',CR,LF
000027C4= 4D 4D 4D 4D 4D 4D ...   2002                  DC.B    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNMMMMMM',CR,LF
00002816= 4D 4D 4D 4D 4D 4D ...   2003                  DC.B    'MMMMMMMMNhymMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNmmmNNNNMMMMMMM',CR,LF
00002868= 4D 4D 4D 4D 4D 4D ...   2004                  DC.B    'MMMMMMMMysohMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNNNNNmdhhmNNMNMMMMMMMM',CR,LF
000028BA= 4D 4D 4D 4D 4D 4D ...   2005                  DC.B    'MMMMMMMMNhdNMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNNNNNNNmmmmmmdyyydNNNMMMMMMMMMMM',CR,LF
0000290C= 4D 4D 4D 4D 4D 4D ...   2006                  DC.B    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNNNNmmmmmmmmddhhhysshdmNNMMMMMMMMMMMMM',CR,LF
0000295E= 4D 4D 4D 4D 4D 4D ...   2007                  DC.B    'MMMMMMMMMMMNMMMMMMMMMMMMMMMMMMMNNNNNNNNNmmmmmmmddddhyyyyo+oydmmNNNNMMMMMMMMMMMMM',CR,LF
000029B0= 4D 4D 4D 4D 4D 4D ...   2008                  DC.B    'MMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNmmmmmmddddddhhyyysossyyhdmmNNNNNMMMMMMMMMMMMMM',CR,LF
00002A02= 4D 4D 4D 4D 4D 4D ...   2009                  DC.B    'MMMMMMMMMMMMMMMMMMMMMMMNNNNNNmmmmmmdddddhhhhhyso+ooosyyhdmmmNNNNNMMMMMMMMMMMMMMM',CR,LF
00002A54= 4D 4D 4D 4D 4D 4D ...   2010                  DC.B    'MMMMMMMMMMMMMMMMMMMMMNNNNmmdddddddhhhhhyyyysoo+++ooosyhdmmmNNNNMMMMMMMMMMMMMMMMM',CR,LF
00002AA6= 4D 4D 4D 4D 4D 4D ...   2011                  DC.B    'MMMMMMMMMMMMMMMMMNNNNmmmddhhhhhhhyyyssossso+/://oosyhddmmmNNNNMMMMMMMMMMMMMMMMMM',CR,LF
00002AF8= 4D 4D 4D 4D 4D 4D ...   2012                  DC.B    'MMMMMMMMMMMMMMMNNNmmdddhhyyyyyyyssoo++oo+/:::/++oshhddmmNNNNNMMMMMMMMMMMMMMMMMMM',CR,LF
00002B4A= 4D 4D 4D 4D 4D 4D ...   2013                  DC.B    'MMMMMMMMMMMMMNNmmddhhyyyysssssoo+//++ooo+//++osyhhdddmmNNNNMMMMMMMMMMMMMMMMMMMMM',CR,LF
00002B9C= 4D 4D 4D 4D 4D 4D ...   2014                  DC.B    'MMMMMMMMMNNNNmmdhhyysssssoooo+///:/++o++/+ooosyhdddmmNNNNMMMMMMMMMMMMMMMMMMMMMMM',CR,LF
00002BEE= 4D 4D 4D 4D 4D 4D ...   2015                  DC.B    'MMMMMMMMNNNmmdhhyssoooo++++++/+oo++++///osssyhhddmmNNNNMMMMMMMMMMMMMMMMMMMMMMMMM',CR,LF
00002C40= 4D 4D 4D 4D 4D 4D ...   2016                  DC.B    'MMMMMMMNNmmdhyysoooo++++++++ooooo+++/+osyyyhhddmmNNNMNMMMMMMMMMMMMNNNNNMMMMMMMMM',CR,LF
00002C92= 4D 4D 4D 4D 4D 4D ...   2017                  DC.B    'MMMMMMNNmdhyso+++++o++++ooooysso++o+ossyyhhddmmNNNMMMMMMMMMMMMMMmysyyydNMMMMMMMM',CR,LF
00002CE4= 4D 4D 4D 4D 4D 4E ...   2018                  DC.B    'MMMMMNNmdhso+////ooossssyyysoo++++osssyyhhddmNNNMMMMMMMMMMMMMMMmossosydNMMMMMMMM',CR,LF
00002D36= 4D 4D 4D 4D 4D 4E ...   2019                  DC.B    'MMMMMNmdys+:-:/oyhdhdhysoos++++++oossyyhhdmmNNMMMMMMMMMMMMMMMNMhoysssydNMMMMMMMM',CR,LF
00002D88= 4D 4D 4D 4D 4E 4E ...   2020                  DC.B    'MMMMNNmhs+-./yydmmNmmmhhyso++++ooossyyhddmNNMMMMMMMMMNNMMMMMMMMmssyhhdNMMMMMMMMM',CR,LF
00002DDA= 4D 4D 4D 4D 4E 4E ...   2021                  DC.B    'MMMMNNdyo:.:shdmNNmmmmhsoo+++ooossyyhddmNNNMMMMMMMMMMMMMMMMMMMMMmhdmNNMMMMMMMMMM',CR,LF
00002E2C= 4D 4D 4D 4D 4D 4E ...   2022                  DC.B    'MMMMMNdyo/.:+sdmmNmmmdooo++++oosyhhddmNNNMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMM',CR,LF
00002E7E= 4D 4D 4D 4D 4D 4E ...   2023                  DC.B    'MMMMMNmhs+-.:oshdmmmh++/+++osyyhddmmNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',CR,LF
00002ED0= 4D 4D 4D 4D 4D 4D ...   2024                  DC.B    'MMMMMMNmhyo/-:/oyso/:/++osyyhddmmNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',CR,LF
00002F22= 4D 4D 4D 4D 4D 4D ...   2025                  DC.B    'MMMMMMMNNmdhso+///+osyyhhddmmNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmMMMMMMMMMMMMM',CR,LF
00002F74= 4D 4D 4D 4D 4D 4D ...   2026                  DC.B    'MMMMMMMMMMNNNmmddddmmmmNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmMMMMMMMMMMMMM',CR,LF
00002FC6= 4D 4D 4D 4D 4D 4D ...   2027                  DC.B    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',CR,LF
00003018= 4D 4D 4D 4D 4D 4D ...   2028                  DC.B    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',CR,LF
0000306A= 20 0D 0A 00             2029                  DC.B    ' ',CR,LF,0                    
0000306E= 41 6C 6C 20 64 6F ...   2030  end_message     DC.B    'All done!  See you later!',CR,LF
00003089= 20 0D 0A                2031                  DC.B    ' ',CR,LF
0000308C= 20 20 20 20 20 20 ...   2032                  DC.B    '                   `-//.```                                                     ',CR,LF         
000030DE= 20 20 20 20 20 20 ...   2033                  DC.B    '                   .ooooooo+.  `                                                ',CR,LF
00003130= 20 20 20 20 20 20 ...   2034                  DC.B    '                ```/oooooo+/+/--.`                                              ',CR,LF
00003182= 20 20 20 20 20 20 ...   2035                  DC.B    '               .+ooooo//++:-----.`                                              ',CR,LF
000031D4= 20 20 20 20 20 20 ...   2036                  DC.B    '               /soooo+----------.                                               ',CR,LF
00003226= 20 20 20 20 20 20 ...   2037                  DC.B    '               .-sooo/:/:--.`.``                                                ',CR,LF
00003278= 20 20 20 20 20 20 ...   2038                  DC.B    '                 .+++ooo+--.                                                    ',CR,LF
000032CA= 20 20 20 20 20 20 ...   2039                  DC.B    '                    `+soo:---`                                                  ',CR,LF
0000331C= 20 20 20 20 20 20 ...   2040                  DC.B    '                     .:ooo+--                                                   ',CR,LF
0000336E= 20 20 20 20 20 20 ...   2041                  DC.B    '                      `:-:/+-      /::o+:                                       ',CR,LF
000033C0= 20 20 20 20 20 20 ...   2042                  DC.B    '                           `::.`  .dhhho//                                      ',CR,LF
00003412= 20 20 20 20 20 20 ...   2043                  DC.B    '                `--/         .:.` :ymmNmy//              `--`                   ',CR,LF
00003464= 20 20 20 20 20 20 ...   2044                  DC.B    '              `-//+.          `..``+mmmmm++/.            :::+                   ',CR,LF
000034B6= 20 20 20 20 20 20 ...   2045                  DC.B    '           `-+++:+:.             ` .dmmmmdsh+/`           -+//.`                ',CR,LF
00003508= 20 20 20 20 20 20 ...   2046                  DC.B    '          `+:o+o+:/o             `--dmNNNNosoo.            ++o///:              ',CR,LF
0000355A= 20 20 20 20 20 20 ...   2047                  DC.B    '         -:/yhdddh/+:         `/+++sydNNNN+//o`           ://+o+/+-             ',CR,LF
000035AC= 20 20 20 20 20 20 ...   2048                  DC.B    '       `:-+hhhdmddh/o.        `/::+mhssyd+::+/+`         .+:oddddy+:`           ',CR,LF
000035FE= 20 20 20 20 20 60 ...   2049                  DC.B    '     `-/:shhhhhmmhhy/+           smdddho/:/os/o+.        //sddddddhs+-          ',CR,LF
00003650= 20 20 20 20 20 2D ...   2050                  DC.B    '     -/:+hhhhhhmmhhhso`          /yyyysso+so` -++       -/yddmhdddddho/-`       ',CR,LF
000036A2= 20 20 20 20 20 2F ...   2051                  DC.B    '     /:/hhhhhhhdmdhhd+-           ..:dyso//+    `      -:ohhdmhhhhhdddyo/:`     ',CR,LF
000036F4= 20 20 20 20 60 6F ...   2052                  DC.B    '    `o+hhhhhhhhdddhhd//--.          .soo+://         `::+hhhmmhhhhhhhhddy++     ',CR,LF
00003746= 20 20 20 60 2B 73 ...   2053                  DC.B    '   `+shhhhhhdhhdddhhhs:..::.        .+:/:://       `.///hhhhhmdhhhhhhhhhhhs-    ',CR,LF
00003798= 20 20 20 2F 73 68 ...   2054                  DC.B    '   /shhhhhhhddhhdhhhyhhyo/:::`      `+::::// -:.`.-//:+hhhhhhmmhhhhhhhhhhhdo.   ',CR,LF
000037EA= 20 20 3A 6F 68 68 ...   2055                  DC.B    '  :ohhhhhhhhddhhmsosso+hhhhs++-.::.`:/:::::+:s//++++oyhhhhhhhmddhyysyhhhhhhy+.  ',CR,LF
0000383C= 60 2D 2B 79 68 68 ...   2056                  DC.B    '`-+yhhhhhhhdddhhss+/+/:yhhhddho/:/o/++/::::+yoshdddddhhhhhhhhdddysssyhhhhhhd++. ',CR,LF
0000388E= 2E 2F 2F 64 68 68 ...   2057                  DC.B    './/dhhhhhhhddddds+o+::+dhhhhdhhy/+/:+oo++:::+hhhdddhhhhyhhshhhdmysoo//shhhhhh:+.',CR,LF
000038E0= 2E 2F 73 68 68 68 ...   2058                  DC.B    './shhhhhhhhyo//yhmho/::yhhhho-:++::::::::::::/o:+dhhyhd+oo+hsddhyso/--+hhhhhdo/+',CR,LF
00003932= 3A 2F 68 68 68 68 ...   2059                  DC.B    ':/hhhhhys/.`   .sdhhy/::+o++::::::///////::::::::yyh-:hoo+++ohhyoo+:-:yhhhhhhdo+',CR,LF
00003984= 2B 2F 64 68 68 79 ...   2060                  DC.B    '+/dhhy+.        `+hhhy+//++++s::+/:----::/+/:::+os/::/+/+o+:-ossoo/--/syyhhhhd+:',CR,LF
000039D6= 6F 2B 64 68 73 2E ...   2061                  DC.B    'o+dhs.            -oh:.-.`` :+/+-........../+:::s-:+::://:` /++/o+--/oo:`-ohhdo-',CR,LF
00003A28= 2B 6F 68 79 60 20 ...   2062                  DC.B    '+ohy`             `.::------o/+.............-o/:// -+/:-`  `+/--::--::++`  -ydo.',CR,LF
00003A7A= 3A 68 64 2D 20 20 ...   2063                  DC.B    ':hd-           `.:///::::++soo...............-s::s.`        -/-:+/------    .ho`',CR,LF
00003ACC= 20 2B 79 60 20 20 ...   2064                  DC.B    ' +y`         `-:-.:+o+oo/--+y-................+/:o//:       `.-o+o--.        oo ',CR,LF
00003B1E= 20 60 3A 60 20 20 ...   2065                  DC.B    ' `:`        -/:-....:+/...-/y--::----.........o/+:::/+/.`  ``-++y. ``        -. ',CR,LF
00003B70= 20 20 20 20 20 20 ...   2066                  DC.B    '          `+/::::::+/.....::s::::::::::--....-ys/:::::o+/:++so+s:               ',CR,LF
00003BC2= 20 20 20 20 20 20 ...   2067                  DC.B    '         /s/:::::o-..---::/os:::::::::::::::sh/:::::::s/::/oso-                 ',CR,LF
00003C14= 20 20 20 20 20 20 ...   2068                  DC.B    '          `+o+/://s.-:::::/ooss/::::::::::::sh+::::::/+ohssss:`                 ',CR,LF
00003C66= 20 20 20 20 20 20 ...   2069                  DC.B    '           `++osssy::/++ossysyooo+::::::/+osso:://++ooos+::-`                   ',CR,LF
00003CB8= 20 20 20 20 20 20 ...   2070                  DC.B    '            `////::+o/:/+ossss:::/oo:---.`:oosssysssooo.                        ',CR,LF
00003D0A= 20 20 20 20 20 20 ...   2071                  DC.B    '               `.-/yo::::::+oy/--.         /+:/+oooos+``                        ',CR,LF
00003D5C= 20 20 20 20 20 20 ...   2072                  DC.B    '                 /-:so//+/++s+             `-o++++s/s/-:-                       ',CR,LF
00003DAE= 20 20 20 20 20 20 ...   2073                  DC.B    '                 :--o:::+++-/                `/:/--:::o::                       ',CR,LF
00003E00= 20 20 20 20 20 20 ...   2074                  DC.B    '                   `+-    -.                   -     .:`                        ',CR,LF
00003E52= 20 0D 0A 00             2075                  DC.B    ' ',CR,LF,0 
00003E56                          2076  
00003E56                          2077      END    START  

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA_CONT           1C5C
ADDA_LONG           1C90
ADDA_WORD           1C82
ADDX_CHECK          1C30
ADD_DN_TO_EA        1CF2
ADD_EA_TO_DN        1CDA
ADD_SPACE           2420
ASCII_TO_HEX        242C
ASD_CHECK_MEMORY_SHIFT  1D68
ASD_CHECK_REGISTER_SHIFT  1F00
ASL_MEMORY_SHIFT    1DB4
ASL_REGISTER_SHIFT  1F82
ASL_REGISTER_SHIFT_IMMEDIATE  1FD4
ASL_REGISTER_SHIFT_REGISTER  1FB8
ASR_MEMORY_SHIFT    1D78
ASR_REGISTER_SHIFT  1F10
ASR_REGISTER_SHIFT_IMMEDIATE  1F62
ASR_REGISTER_SHIFT_REGISTER  1F46
BCLR_DYNAMIC_CHECK  121A
BEGIN               7000
BOUND_ERROR         2492
BUFFER              265B
BYTE_SIZE           23E0
CHAR_COUNT          252D
CHECK_SUBQ          1776
CHECK_SUBX          1A6E
CMPA_CHECK          1B1C
CODE0000            11E2
CODE0001            133C
CODE0010            1394
CODE0011            13E0
CODE0100            1442
CODE0101            1764
CODE0110            17DC
CODE0111            1952
CODE1000            1956
CODE1001            1A4C
CODE1010            1AFE
CODE1011            1B02
CODE1100            1BBA
CODE1101            1C10
CODE1110            1D1A
CODE1111            21F0
CR                  D
CURRENT             252A
DATA_ERROR          21F4
DECODED             248A
DISCARD             274B
DISPLACEMENT_BYTE   191E
DISPLACEMENT_CHECK  18FC
DISPLACEMENT_LONG   1940
DISPLACEMENT_WORD   192E
EAMODE              22A4
EAMODE0             22E4
EAMODE1             22F0
EAMODE2             22FC
EAMODE3             2310
EAMODE4             2328
EAMODE5             2340
EAMODE6             234C
EAMODE7             2358
EMPTY_LINE          2633
END                 FFFFFE
END_CHECK           2230
END_INPUT           26FB
END_MESSAGE         306E
END_PROMPT          255D
EVEN_CHECK          24A2
GET_BYTE            2370
GET_END             105E
GET_LONG            239C
GET_SIZE            23C8
GET_SPACE           240A
GET_START           101A
GET_WORD            2386
GREETING            278E
HEX_TO_ASCII        24C8
HTA_CONTINUE        2500
HTA_ERROR           251C
HTA_ERROR_MSG       2637
HTA_FINISH          251A
HTA_LOOP            24E6
HTA_NUMBER          24FC
HTA_RESULT          250C
IMMEDIATE_DATA      23B2
INPUT_ERROR         2589
IS_ADD              1C9E
IS_ADDA             1C40
IS_BCLR_DYNAMIC     12BE
IS_BCLR_STATIC      12FC
IS_BCS              1844
IS_BGE              18A0
IS_BLT              18CE
IS_BRA              1816
IS_BVC              1872
IS_CMP              1B2E
IS_CMPI             1270
IS_DIVS             1982
IS_EOR              1B70
IS_JSR              1550
IS_LEA              14FE
IS_MOVEA            1436
IS_MOVEM_LONG_MEM_TO_REG  1666
IS_MOVEM_LONG_REG_TO_MEM  15DA
IS_MOVEM_WORD_MEM_TO_REG  1620
IS_MOVEM_WORD_REG_TO_MEM  1594
IS_MULS             1BC6
IS_NEG              14C6
IS_NOP              14A6
IS_OR               19CC
IS_ORI              1226
IS_RTS              14B6
IS_SUB              1A82
IS_SUBQ             1788
JMP_TABLE           1182
LF                  A
LINE_COUNT          252C
LONG_SIZE           23FC
LSD_CHECK_MEMORY_SHIFT  1DF0
LSD_CHECK_REGISTER_SHIFT  1FF4
LSL_MEMORY_SHIFT    1E3C
LSL_REGISTER_SHIFT  2076
LSL_REGISTER_SHIFT_IMMEDIATE  20C8
LSL_REGISTER_SHIFT_REGISTER  20AC
LSR_MEMORY_SHIFT    1E00
LSR_REGISTER_SHIFT  2004
LSR_REGISTER_SHIFT_IMMEDIATE  2056
LSR_REGISTER_SHIFT_REGISTER  203A
MAIN                109C
MAX_CHAR            A
MAX_LINE            14
MEMORY_SHIFT        1D4C
MEM_TO_REG          16EC
MEM_TO_REG_CONT     1708
MEM_TO_REG_PRE      1728
MOVEA_CHECK         142C
MOVEM_GET_REGISTER  1752
MOVEM_MASK_LOOP     1730
MOVEM_MASK_LOOP_CONT  1744
MOVEM_POST          274C
MOVEM_PRE           276D
NOT_EVEN            25B4
ODD_ERROR           24B6
OP_CODE             112C
OR_DN_TO_EA         1A24
OR_EA_TO_DN         1A04
PRINT               10D2
PRINT_BREAK         10FE
PRINT_CONT          10FC
REG_TO_MEM          16AC
REG_TO_MEM_CONT     16BA
REG_TO_MEM_PRE      16E4
RESET_MESSAGE       25D4
RESULT              2490
ROD_CHECK_MEMORY_SHIFT  1E78
ROD_CHECK_REGISTER_SHIFT  20E8
ROL_MEMORY_SHIFT    1EC4
ROL_REGISTER_SHIFT  216A
ROL_REGISTER_SHIFT_IMMEDIATE  21BC
ROL_REGISTER_SHIFT_REGISTER  21A0
ROR_MEMORY_SHIFT    1E88
ROR_REGISTER_SHIFT  20F8
ROR_REGISTER_SHIFT_IMMEDIATE  214A
ROR_REGISTER_SHIFT_REGISTER  212E
SCREEN_ENTER        2618
SHIFT               C
SHIFT_IMMEDIATE_CONT  21E4
SHIFT_IMMEDIATE_DATA  21DC
SHIFT_IMMEDIATE_ZERO  21EC
STACK               7000
START               1000
START_INPUT         26AB
START_PROMPT        252E
SUBQ_DATA           17C8
SUBQ_DATA_CONT      17D0
SUBQ_DATA_ZERO      17D8
SUB_DN_TO_EA        1AD6
SUB_EA_TO_DN        1ABE
TRANSLATE           2446
UPPERCASE           2486
WORD_SIZE           23EE
