00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.01
Created On: 5/24/2014 11:52:47 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Derek Willms, Binh Nguyen, Brian Quigley
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000                             7      
00000000  =00000000                  8  begin           EQU     $00000000
00000000  =00FFFFFE                  9  end             EQU     $00FFFFFE
00000000  =00007000                 10  stack           EQU     $7000               * Stack address
00000000  =0000000C                 11  shift           EQU     12                  * Shift 12 bits
00000000                            12  
00000000= 0001                      13  current         DC.W    1
00000002                            14                  
00001000                            15  START:          ORG     $1000
00001000                            16  
00001000  4FF8 7000                 17  start           LEA     stack,SP            * Load the Stack Pointer
00001004  43F9 0000156E             18                  LEA     greeting,A1         * Assign greeting to A1
0000100A  103C 000E                 19                  MOVE.B  #14,D0              * Assign prompt task code to D0
0000100E  4E4F                      20                  TRAP    #15                 * Display greeting
00001010                            21                  
00001010  43F9 00001591             22  get_start       LEA     start_prompt,A1     * Assign starting address prompt to A1
00001016  103C 000E                 23                  MOVE.B  #14,D0              * Assign prompt task code to D0
0000101A  4E4F                      24                  TRAP    #15                 * Display starting address prompt
0000101C                            25                  
0000101C  43F9 000016C4             26                  LEA     start_input,A1      * Assign start_input as address to store input
00001022  103C 0002                 27                  MOVE.B  #2,D0               * Assign input task code to D0
00001026  4E4F                      28                  TRAP    #15                 * Store user input in A1
00001028                            29                  
00001028  4EB9 00001470             30                  JSR     ascii_to_hex        * Translate ASCII input to HEX
0000102E  4EB9 000014E6             31                  JSR     even_check          * Check if given address is odd
00001034  B67C FFFF                 32                  CMP.W   #-1,D3              * Check result of odd check
00001038  67D6                      33                  BEQ     get_start           * If odd, display an error and ask for new starting address
0000103A                            34                  
0000103A  7A00                      35                  MOVE.L  #begin,D5           * Assign minimum address bound to D5
0000103C  B685                      36                  CMP.L   D5,D3               * Compare address to minimum bound
0000103E  6D00 0496                 37                  BLT     bound_error         * Error if address is below minimum
00001042  2A3C 00FFFFFE             38                  MOVE.L  #end,D5             * Assign maximum address bound to D5
00001048  B685                      39                  CMP.L   D5,D3               * Compare address to maximum bound
0000104A  6E00 048A                 40                  BGT     bound_error         * Error if address is above maximum
0000104E  2C43                      41                  MOVEA.L D3,A6               * Save the lower address into A6
00001050                            42                  
00001050  43F9 000015BD             43  get_end         LEA     end_prompt,A1       * Assign ending address prompt to A1
00001056  103C 000E                 44                  MOVE.B  #14,D0              * Assign prompt task code to D0
0000105A  4E4F                      45                  TRAP    #15                 * Display ending address prompt
0000105C                            46                  
0000105C  43F9 00001714             47                  LEA     end_input,A1        * Assign end_input as address to store input
00001062  103C 0002                 48                  MOVE.B  #2,D0               * Assign input task code to D0
00001066  4E4F                      49                  TRAP    #15                 * Store user input in A1
00001068                            50                  
00001068  4EB9 00001470             51                  JSR     ascii_to_hex        * Translate ASCII input to HEX
0000106E  4EB9 000014E6             52                  JSR     even_check          * Check if given address is odd
00001074  B67C FFFF                 53                  CMP.W   #-1,D3              * Check result of odd check
00001078  67D6                      54                  BEQ     get_end             * If odd, display an error and ask for new starting address
0000107A                            55                  
0000107A  B68E                      56                  CMP.L   A6,D3               * Compare address to lower address
0000107C  6D00 0458                 57                  BLT     bound_error         * Error if address is below lower address
00001080  B685                      58                  CMP.L   D5,D3               * Compare address to maximum bound
00001082  6E00 0452                 59                  BGT     bound_error         * Error if address is above maximum
00001086  2C03                      60                  MOVE.L  D3,D6               * Save the upper address into D6
00001088                            61                  
00001088  4282                      62                  CLR.L   D2                  * Clear D2
0000108A  4283                      63                  CLR.L   D3                  * Clear D3
0000108C  4285                      64                  CLR.L   D5                  * Clear D5
0000108E                            65                  
0000108E                            66  
0000108E  4280                      67  main            CLR.L   D0                  * Clear D0
00001090  4281                      68                  CLR.L   D1                  * Clear D1
00001092  200E                      69                  MOVE.L  A6,D0               * Get current memory pointer in D0
00001094  123C 0004                 70                  MOVE.B  #4,D1               * Size for address is 4 bytes
00001098  227C 00001674             71                  MOVE.L  #buffer,A1          * Set A1 to point to the print buffer
0000109E  4EB9 0000150C             72                  JSR     hex_to_ascii        * Translate hex to ascii
000010A4  12FC 0009                 73                  MOVE.B  #$9,(A1)+           * Add a tab
000010A8                            74                  
000010A8  6000 001C                 75                  BRA     op_code             * Begin decode 
000010AC                            76                  
000010AC                            77  Print           
000010AC  12BC 0000                 78                  MOVE.B  #$00,(A1)            * Add terminator              
000010B0  4280                      79                  CLR.L   D0                   * Clear D0   
000010B2  103C 000D                 80                  MOVE.B  #13,D0               * Load Trap task number 13 for printing
000010B6  43F9 00001674             81                  LEA     buffer,A1            * Load print buffer into A1 
000010BC  4E4F                      82                  TRAP    #15                  * Print the buffer
000010BE                            83                  
000010BE  BC8E                      84                  CMP.L   A6,D6                * Compare current memory pointer with ending address 
000010C0  6F00 0216                 85                  BLE     end_check            * Less than equal zero, reach the end
000010C4  60C8                      86                  BRA     main                 * Go to next memory
000010C6                            87  
000010C6                            88  *////////////////////////////////////////////////////////////////////////////////////////
000010C6                            89  *op_code: get the data from current memory pointer, advance the memory pointer, separate 
000010C6                            90  *         the bits, and jump to the corresponding op_code decoding
000010C6                            91  *D0: Internal 
000010C6                            92  *D1: Internal
000010C6                            93  *D2: Store 3 bits for Source REGISTER
000010C6                            94  *D3: Store 3 bits for Source MODE
000010C6                            95  *D4: Store 3 bits for Destination MODE
000010C6                            96  *D5: Store 3 bits for Destination REGISTER
000010C6                            97  *current: Store the WORD data
000010C6                            98  *////////////////////////////////////////////////////////////////////////////////////////                
000010C6  41F9 00001118             99  op_code         LEA     jmp_table,A0                    *Index into the table
000010CC  4280                     100                  CLR.L   D0                              *Zero it
000010CE                           101                  
000010CE  31DE 0000                102                  MOVE.W  (A6)+,current                   *Get WORD and advance memory pointer                
000010D2  3038 0000                103                  MOVE.W  current,D0                      *Copy WORD to D0            
000010D6  3200                     104                  MOVE.W  D0,D1                           *Copy Word data to D1
000010D8  48E7 8000                105                  MOVEM.L D0,-(SP)                        *Copy Word data to the stack
000010DC                           106      
000010DC  0241 0007                107                  ANDI.W  #%0000000000000111,D1           *Get last 3 bits Source REG
000010E0  1401                     108                  MOVE.B  D1,D2                           *Store in D2
000010E2                           109      
000010E2  E658                     110                  ROR.W   #3,D0                           *Rotate D0 right 3 bits
000010E4  3200                     111                  MOVE.W  D0,D1                           *Copy Word to D1
000010E6  0241 0007                112                  ANDI.W  #%0000000000000111,D1           *Get last 3 bits Source MODE
000010EA  1601                     113                  MOVE.B  D1,D3                           *Store in D3
000010EC                           114      
000010EC  E658                     115                  ROR.W   #3,D0                           *Rotate D0 right 3 bits
000010EE  3200                     116                  MOVE.W  D0,D1                           *Copy Word to D1
000010F0  0241 0007                117                  ANDI.W  #%0000000000000111,D1           *Get last 3 bits Dest MODE
000010F4  1801                     118                  MOVE.B  D1,D4                           *Store in D4
000010F6                           119      
000010F6  E658                     120                  ROR.W   #3,D0                           *Rotate D0 right 3 bits
000010F8  3200                     121                  MOVE.W  D0,D1                           *Copy Word to D1
000010FA  0241 0007                122                  ANDI.W  #%0000000000000111,D1           *Get last 3 bits Dest REG
000010FE  1A01                     123                  MOVE.B  D1,D5                           *Store in D5
00001100                           124      
00001100  4CDF 0001                125                  MOVEM.L (SP)+,D0                        *Pop Word data from stack to D0
00001104  4281                     126                  CLR.L   D1                              *Clear D1
00001106                           127  
00001106  123C 000C                128                  MOVE.B  #shift,D1                       *Shift 12 bits to the right 
0000110A  E268                     129                  LSR.W   D1,D0                           *Move the bits
0000110C                           130      
0000110C  4281                     131                  CLR.L   D1                              *Clear D1
0000110E  1200                     132                  MOVE.B  D0,D1                           *Copy 4 bits to D1
00001110                           133      
00001110  C0FC 0006                134                  MULU    #6,D0                           *Form offset
00001114  4EB0 0000                135                  JSR     0(A0,D0)                        *Jump indirect with index
00001118                           136  
00001118                           137  jmp_table
00001118  4EF9 00001178            138      JMP     code0000                        *Bit manipulation/MOVEP/Immediate
0000111E  4EF9 0000117C            139      JMP     code0001                        *Move Byte
00001124  4EF9 000011CE            140      JMP     code0010                        *Move Long
0000112A  4EF9 0000121E            141      JMP     code0011                        *Move Word
00001130  4EF9 0000126E            142      JMP     code0100                        *Miscellaneous
00001136  4EF9 00001272            143      JMP     code0101                        *ADDQ/SUBQ/Scc/DBcc
0000113C  4EF9 00001276            144      JMP     code0110                        *BSR,BRA,Bcc
00001142  4EF9 0000127A            145      JMP     code0111                        *MOVEQ
00001148  4EF9 0000127E            146      JMP     code1000                        *OR/DIV/SBCD
0000114E  4EF9 00001282            147      JMP     code1001                        *SUB/SUBX
00001154  4EF9 00001286            148      JMP     code1010                        *Unassigned
0000115A  4EF9 0000128A            149      JMP     code1011                        *CMP/EOR
00001160  4EF9 0000128E            150      JMP     code1100                        *AND/MUL/ABCD/EXG
00001166  4EF9 00001292            151      JMP     code1101                        *ADD/ADDA/ADDX
0000116C  4EF9 00001296            152      JMP     code1110                        *Shift/Rotate
00001172  4EF9 0000129A            153      JMP     code1111                        *Special/Reserved
00001178                           154      
00001178  4E72 2700                155  code0000    STOP    #$2700
0000117C                           156  
0000117C                           157  *////////////////////////////////////////////////////////////////////////////////////////
0000117C                           158  *code0001: MOVE Byte
0000117C                           159  *////////////////////////////////////////////////////////////////////////////////////////  
0000117C                           160  code0001
0000117C  12FC 004D                161      MOVE.B  #'M',(A1)+
00001180  12FC 004F                162      MOVE.B  #'O',(A1)+
00001184  12FC 0056                163      MOVE.B  #'V',(A1)+
00001188  12FC 0045                164      MOVE.B  #'E',(A1)+
0000118C  12FC 002E                165      MOVE.B  #'.',(A1)+
00001190  12FC 0042                166      MOVE.B  #'B',(A1)+
00001194  12FC 0020                167      MOVE.B  #' ',(A1)+
00001198  12FC 0020                168      MOVE.B  #' ',(A1)+
0000119C  12FC 0020                169      MOVE.B  #' ',(A1)+
000011A0  12FC 0020                170      MOVE.B  #' ',(A1)+
000011A4                           171      
000011A4  4280                     172      CLR.L   D0                              *Clear D0
000011A6  103C 0001                173      MOVE.B  #1,D0                           *size is 1 byte
000011AA                           174      
000011AA                           175         
000011AA  4EB9 000012E8            176      JSR     EAMode                          *Jump to EAMode
000011B0                           177      
000011B0  12FC 002C                178      MOVE.B  #',',(A1)+
000011B4                           179      
000011B4  4282                     180      CLR.L   D2
000011B6  4283                     181      CLR.L   D3
000011B8  1604                     182      MOVE.B  D4,D3                           *Get Destination MODE
000011BA  1405                     183      MOVE.B  D5,D2                           *Get Source REG
000011BC                           184      
000011BC  B63C 0001                185      CMP.B   #1,D3                           *An not allowed
000011C0  6700 00EC                186      BEQ     data_error
000011C4                           187  
000011C4  4EB9 000012E8            188      JSR     EAMode                          *Jump to EAMode
000011CA                           189      
000011CA  6000 FEE0                190      BRA     Print
000011CE                           191  
000011CE                           192  *////////////////////////////////////////////////////////////////////////////////////////
000011CE                           193  *code0001: MOVE Long
000011CE                           194  *//////////////////////////////////////////////////////////////////////////////////////// 
000011CE                           195  code0010    
000011CE  12FC 004D                196      MOVE.B  #'M',(A1)+
000011D2  12FC 004F                197      MOVE.B  #'O',(A1)+
000011D6  12FC 0056                198      MOVE.B  #'V',(A1)+
000011DA  12FC 0045                199      MOVE.B  #'E',(A1)+
000011DE                           200      
000011DE  4EB9 0000129E            201      JSR     MOVEA_check                     *Check for MOVEA      
000011E4                           202  
000011E4  12FC 002E                203      MOVE.B  #'.',(A1)+
000011E8  12FC 004C                204      MOVE.B  #'L',(A1)+
000011EC  12FC 0020                205      MOVE.B  #' ',(A1)+
000011F0  12FC 0020                206      MOVE.B  #' ',(A1)+
000011F4  12FC 0020                207      MOVE.B  #' ',(A1)+
000011F8  12FC 0020                208      MOVE.B  #' ',(A1)+
000011FC                           209      
000011FC  4280                     210      CLR.L   D0                              *Clear D0
000011FE  103C 0004                211      MOVE.B  #4,D0                           *size is 4 bytes
00001202                           212      
00001202                           213         
00001202  4EB9 000012E8            214      JSR     EAMode                          *Jump to EAMode
00001208                           215      
00001208  12FC 002C                216      MOVE.B  #',',(A1)+
0000120C                           217      
0000120C  4282                     218      CLR.L   D2
0000120E  4283                     219      CLR.L   D3
00001210  1604                     220      MOVE.B  D4,D3                           *Get Destination MODE
00001212  1405                     221      MOVE.B  D5,D2                           *Get Source REG
00001214                           222     
00001214  4EB9 000012E8            223      JSR     EAMode                          *Jump to EAMode
0000121A                           224      
0000121A  6000 FE90                225      BRA     Print
0000121E                           226  
0000121E                           227  
0000121E                           228  *////////////////////////////////////////////////////////////////////////////////////////
0000121E                           229  *code0011: MOVE Word
0000121E                           230  *//////////////////////////////////////////////////////////////////////////////////////// 
0000121E                           231  code0011    
0000121E  12FC 004D                232      MOVE.B  #'M',(A1)+
00001222  12FC 004F                233      MOVE.B  #'O',(A1)+
00001226  12FC 0056                234      MOVE.B  #'V',(A1)+
0000122A  12FC 0045                235      MOVE.B  #'E',(A1)+
0000122E                           236      
0000122E  4EB9 0000129E            237      JSR     MOVEA_check                     *Check for MOVEA
00001234                           238      
00001234  12FC 002E                239      MOVE.B  #'.',(A1)+
00001238  12FC 0057                240      MOVE.B  #'W',(A1)+
0000123C  12FC 0020                241      MOVE.B  #' ',(A1)+
00001240  12FC 0020                242      MOVE.B  #' ',(A1)+
00001244  12FC 0020                243      MOVE.B  #' ',(A1)+
00001248  12FC 0020                244      MOVE.B  #' ',(A1)+
0000124C                           245      
0000124C  4280                     246      CLR.L   D0                              *Clear D0
0000124E  103C 0002                247      MOVE.B  #2,D0                           *size is 2 bytes
00001252                           248      
00001252                           249         
00001252  4EB9 000012E8            250      JSR     EAMode                          *Jump to EAMode
00001258                           251      
00001258  12FC 002C                252      MOVE.B  #',',(A1)+
0000125C                           253      
0000125C  4282                     254      CLR.L   D2
0000125E  4283                     255      CLR.L   D3
00001260  1604                     256      MOVE.B  D4,D3                           *Get Destination MODE
00001262  1405                     257      MOVE.B  D5,D2                           *Get Source REG
00001264                           258      
00001264  4EB9 000012E8            259      JSR     EAMode                          *Jump to EAMode
0000126A                           260      
0000126A  6000 FE40                261      BRA     Print
0000126E                           262  
0000126E                           263  
0000126E  4E72 2700                264  code0100    STOP    #$2700
00001272                           265  
00001272  4E72 2700                266  code0101    STOP    #$2700
00001276  4E72 2700                267  code0110    STOP    #$2700
0000127A  4E72 2700                268  code0111    STOP    #$2700
0000127E  4E72 2700                269  code1000    STOP    #$2700
00001282  4E72 2700                270  code1001    STOP    #$2700
00001286  4E72 2700                271  code1010    STOP    #$2700
0000128A  4E72 2700                272  code1011    STOP    #$2700
0000128E  4E72 2700                273  code1100    STOP    #$2700
00001292  4E72 2700                274  code1101    STOP    #$2700
00001296  4E72 2700                275  code1110    STOP    #$2700
0000129A  6000 0012                276  code1111    BRA     data_error
0000129E                           277  
0000129E                           278  *////////////////////////////////////////////////////////////////////////////////////////
0000129E                           279  *MOVEA_check: check if MOVEA, then add 'A' to print buffer
0000129E                           280  *D4: hold the Destination MODE for comparison
0000129E                           281  *//////////////////////////////////////////////////////////////////////////////////////// 
0000129E                           282  MOVEA_check
0000129E  B83C 0001                283      CMP.B   #1,D4                           
000012A2  6700 0004                284      BEQ     is_MOVEA
000012A6  4E75                     285      RTS
000012A8                           286  
000012A8                           287  is_MOVEA
000012A8  12F8 0041                288      MOVE.B  'A',(A1)+
000012AC  4E75                     289      RTS
000012AE                           290  
000012AE                           291  
000012AE                           292  *////////////////////////////////////////////////////////////////////////////////////////
000012AE                           293  *data_error: current WORD couldn't be decoded, print the WORD data
000012AE                           294  *//////////////////////////////////////////////////////////////////////////////////////// 
000012AE                           295  data_error
000012AE  12FC 0044                296                  MOVE.B  #'D',(A1)+
000012B2  12FC 0041                297                  MOVE.B  #'A',(A1)+
000012B6  12FC 0054                298                  MOVE.B  #'T',(A1)+
000012BA  12FC 0041                299                  MOVE.B  #'A',(A1)+
000012BE  12FC 0009                300                  MOVE.B  #$9,(A1)+           * Add a tab
000012C2                           301                  
000012C2  4280                     302                  CLR.L   D0
000012C4  3038 0000                303                  MOVE.W  current,D0          * Copy the WORD data to D0
000012C8  4281                     304                  CLR.L   D1
000012CA  123C 0002                305                  MOVE.B  #2,D1               * Byte size is 2
000012CE                           306                 
000012CE  4EB9 0000150C            307                  JSR     hex_to_ascii
000012D4  6000 FDD6                308                  BRA     Print
000012D8                           309  
000012D8                           310  
000012D8                           311      
000012D8                           312  end_check       
000012D8                           313                  
000012D8  43F9 00001634            314                  LEA     end_message,A1      * Assign end message to A1
000012DE  103C 000E                315                  MOVE.B  #14,D0              * Assign prompt task code to D0
000012E2  4E4F                     316                  TRAP    #15                 * Display end message
000012E4  4E72 2700                317                  STOP    #$00002700          * Stop                
000012E8                           318  
000012E8                           319  ***************************************************************************************************
000012E8                           320  ***************************************************************************************************
000012E8                           321  *
000012E8                           322  * SUBROUTINES
000012E8                           323  *
000012E8                           324  ***************************************************************************************************
000012E8                           325  ***************************************************************************************************
000012E8                           326  
000012E8                           327  *////////////////////////////////////////////////////////////////////////////////////////
000012E8                           328  *EAMode: take in the 6 bits EA and branch to the corresponding EA mode
000012E8                           329  *D0: byte size for immediate data
000012E8                           330  *D3: the 3 bits EA MODE
000012E8                           331  *D4: the 3 bits EA REG
000012E8                           332  *//////////////////////////////////////////////////////////////////////////////////////// 
000012E8                           333  EAMode
000012E8  B63C 0000                334      CMP.B   #0,D3
000012EC  6700 003A                335      BEQ     EAmode0
000012F0  B63C 0001                336      CMP.B   #1,D3
000012F4  6700 003E                337      BEQ     EAmode1
000012F8  B63C 0002                338      CMP.B   #2,D3
000012FC  6700 0042                339      BEQ     EAmode2
00001300  B63C 0003                340      CMP.B   #3,D3
00001304  6700 004E                341      BEQ     EAmode3
00001308  B63C 0004                342      CMP.B   #4,D3
0000130C  6700 005E                343      BEQ     EAmode4
00001310  B63C 0005                344      CMP.B   #5,D3
00001314  6700 006E                345      BEQ     EAmode5
00001318  B63C 0006                346      CMP.B   #6,D3
0000131C  6700 00A4                347      BEQ     EAmode6
00001320  B63C 0007                348      CMP.B   #7,D3
00001324  6700 00DA                349      BEQ     EAmode7    
00001328                           350        
00001328                           351  EAmode0
00001328  12FC 0044                352      MOVE.B  #'D',(A1)+                  
0000132C  0642 0030                353      ADD     #$30,D2                         *Convert REG# to ASCII
00001330  12C2                     354      MOVE.B  D2,(A1)+                        *Add to buffer
00001332                           355  
00001332  4E75                     356      RTS    
00001334                           357      
00001334                           358  EAmode1
00001334  12FC 0041                359      MOVE.B  #'A',(A1)+                  
00001338  0642 0030                360      ADD     #$30,D2                         *Convert REG# to ASCII
0000133C  12C2                     361      MOVE.B  D2,(A1)+                        *Add to buffer
0000133E                           362      
0000133E  4E75                     363      RTS
00001340                           364  
00001340                           365  EAmode2
00001340  12FC 0028                366      MOVE.B  #'(',(A1)+
00001344  12FC 0041                367      MOVE.B  #'A',(A1)+                  
00001348  0642 0030                368      ADD     #$30,D2                         *Convert REG# to ASCII
0000134C  12C2                     369      MOVE.B  D2,(A1)+                        *Add to buffer
0000134E  12FC 0029                370      MOVE.B  #')',(A1)+
00001352                           371  
00001352  4E75                     372      RTS
00001354                           373  
00001354                           374  EAmode3
00001354  12FC 0028                375      MOVE.B  #'(',(A1)+
00001358  12FC 0041                376      MOVE.B  #'A',(A1)+                  
0000135C  0642 0030                377      ADD     #$30,D2                         *Convert REG# to ASCII
00001360  12C2                     378      MOVE.B  D2,(A1)+                        *Add to buffer
00001362  12FC 0029                379      MOVE.B  #')',(A1)+
00001366  12FC 002B                380      MOVE.B  #'+',(A1)+
0000136A                           381  
0000136A  4E75                     382      RTS
0000136C                           383  
0000136C                           384  EAmode4
0000136C  12FC 002D                385      MOVE.B  #'-',(A1)+
00001370  12FC 0028                386      MOVE.B  #'(',(A1)+
00001374  12FC 0041                387      MOVE.B  #'A',(A1)+                  
00001378  0642 0030                388      ADD     #$30,D2                         *Convert REG# to ASCII
0000137C  12C2                     389      MOVE.B  D2,(A1)+                        *Add to buffer
0000137E  12FC 0029                390      MOVE.B  #')',(A1)+
00001382                           391  
00001382  4E75                     392      RTS
00001384                           393  
00001384                           394  EAmode5
00001384  12FC 0049                395      MOVE.B  #'I',(A1)+
00001388  12FC 004E                396      MOVE.B  #'N',(A1)+
0000138C  12FC 0056                397      MOVE.B  #'V',(A1)+
00001390  12FC 0041                398      MOVE.B  #'A',(A1)+
00001394  12FC 004C                399      MOVE.B  #'L',(A1)+
00001398  12FC 0049                400      MOVE.B  #'I',(A1)+
0000139C  12FC 0044                401      MOVE.B  #'D',(A1)+
000013A0  12FC 0020                402      MOVE.B  #' ',(A1)+
000013A4  12FC 0045                403      MOVE.B  #'E',(A1)+
000013A8  12FC 0041                404      MOVE.B  #'A',(A1)+
000013AC  12FC 0020                405      MOVE.B  #' ',(A1)+
000013B0  12FC 004D                406      MOVE.B  #'M',(A1)+
000013B4  12FC 004F                407      MOVE.B  #'O',(A1)+
000013B8  12FC 0044                408      MOVE.B  #'D',(A1)+
000013BC  12FC 0045                409      MOVE.B  #'E',(A1)+
000013C0                           410  
000013C0  4E75                     411      RTS    
000013C2                           412   
000013C2                           413  EAmode6
000013C2  12FC 0049                414      MOVE.B  #'I',(A1)+
000013C6  12FC 004E                415      MOVE.B  #'N',(A1)+
000013CA  12FC 0056                416      MOVE.B  #'V',(A1)+
000013CE  12FC 0041                417      MOVE.B  #'A',(A1)+
000013D2  12FC 004C                418      MOVE.B  #'L',(A1)+
000013D6  12FC 0049                419      MOVE.B  #'I',(A1)+
000013DA  12FC 0044                420      MOVE.B  #'D',(A1)+
000013DE  12FC 0020                421      MOVE.B  #' ',(A1)+
000013E2  12FC 0045                422      MOVE.B  #'E',(A1)+
000013E6  12FC 0041                423      MOVE.B  #'A',(A1)+
000013EA  12FC 0020                424      MOVE.B  #' ',(A1)+
000013EE  12FC 004D                425      MOVE.B  #'M',(A1)+
000013F2  12FC 004F                426      MOVE.B  #'O',(A1)+
000013F6  12FC 0044                427      MOVE.B  #'D',(A1)+
000013FA  12FC 0045                428      MOVE.B  #'E',(A1)+
000013FE                           429  
000013FE  4E75                     430      RTS
00001400                           431  
00001400                           432  EAmode7
00001400  B43C 0000                433      CMP.B   #0,D2                           *WORD addressing mode
00001404  6700 0028                434      BEQ     get_word  
00001408                           435    
00001408  B43C 0001                436      CMP.B   #1,D2                           *LONG WORD addressing mode        
0000140C  6700 0036                437      BEQ     get_long                   
00001410                           438      
00001410  B43C 0004                439      CMP.B   #4,D2                           *IMMEDIATE DATA addressing mode
00001414  6700 0044                440      BEQ     IMMEDIATE_DATA
00001418                           441  
00001418                           442  get_byte
00001418  12FC 0024                443      MOVE.B  #'$',(A1)+    
0000141C  4280                     444      CLR.L   D0                              *Clear D0
0000141E  301E                     445      MOVE.W  (A6)+,D0                        *Get next WORD from memory
00001420  4281                     446      CLR.L   D1                              *Clear D1
00001422  123C 0001                447      MOVE.B  #1,D1                           *Byte size is 1  
00001426                           448      
00001426  4EB9 0000150C            449      JSR     hex_to_ascii
0000142C                           450      
0000142C  4E75                     451      RTS
0000142E                           452  
0000142E                           453  get_word
0000142E  12FC 0024                454      MOVE.B  #'$',(A1)+    
00001432  4280                     455      CLR.L   D0                              *Clear D0
00001434  301E                     456      MOVE.W  (A6)+,D0                        *Get next WORD from memory
00001436  4281                     457      CLR.L   D1                              *Clear D1
00001438  123C 0002                458      MOVE.B  #2,D1                           *Byte size is 2  
0000143C                           459      
0000143C  4EB9 0000150C            460      JSR     hex_to_ascii
00001442                           461      
00001442  4E75                     462      RTS
00001444                           463      
00001444                           464      
00001444                           465  get_long
00001444  12FC 0024                466      MOVE.B  #'$',(A1)+
00001448  4280                     467      CLR.L   D0                              *Clear D0
0000144A  201E                     468      MOVE.L  (A6)+,D0                        *Get next LONG WORD from memory
0000144C  4281                     469      CLR.L   D1                              *Clear D1
0000144E  123C 0004                470      MOVE.B  #4,D1                           *Byte size is 4
00001452                           471      
00001452  4EB9 0000150C            472      JSR     hex_to_ascii 
00001458                           473  
00001458  4E75                     474      RTS
0000145A                           475  
0000145A                           476  immediate_data    
0000145A  12FC 0023                477      MOVE.B  #'#',(A1)+
0000145E  B03C 0002                478      CMP.B   #2,D0                           *Is the size WORD
00001462  67CA                     479      BEQ     get_word    
00001464  B03C 0004                480      CMP.B   #4,D0                           *Is the size LONG WORD
00001468  67DA                     481      BEQ     get_long
0000146A  B03C 0001                482      CMP.B   #1,D0                           *Is the size BYTE
0000146E  67A8                     483      BEQ     get_byte
00001470                           484  
00001470                           485  
00001470                           486  *////////////////////////////////////////////////////////////////////////////////////////
00001470                           487  *ascii_to_hex: transforms ASCII input into a hexadecimal address, returns error if invalid characters
00001470                           488  *D1: ASCII parameter to be converted
00001470                           489  *D2: Internal data used for comparison
00001470                           490  *D3: Return data
00001470                           491  *D6: Internal data used for NULL comparison
00001470                           492  *////////////////////////////////////////////////////////////////////////////////////////
00001470  7C00                     493  ascii_to_hex    MOVEQ   #$0,D6              * Clear D6 for null comparison
00001472  7600                     494                  MOVEQ   #$0,D3              * Clear D3 for new data
00001474  B203                     495                  CMP.B   D3,D1               * Null check on string
00001476  6700 005E                496                  BEQ     bound_error         * Error if null
0000147A  0C41 0000                497                  CMPI    #$0,D1              * Character check on string
0000147E  6F00 0056                498                  BLE     bound_error         * Error if less than 0
00001482  0C41 0008                499                  CMPI    #$8,D1              * Character check on string
00001486  6E00 004E                500                  BGT     bound_error         * Error if more than 8 characters
0000148A                           501                  
0000148A  1419                     502  translate       MOVE.B  (A1)+,D2            * Move next character into D2
0000148C  B406                     503                  CMP.B   D6,D2               * Null check on character
0000148E  6700 0044                504                  BEQ     result              * End of input if null
00001492  B43C 0066                505                  CMP.B   #102,D2             * Compare with 102 (highest character code)
00001496  6E00 003E                506                  BGT     bound_error         * Error if character is higher than 102
0000149A  B43C 0060                507                  CMP.B   #96,D2              * Compare with 96 (lowest lowercase hex)
0000149E  6E00 0036                508                  BGT     bound_error         * Error if character is lowercase
000014A2  B43C 0046                509                  CMP.B   #70,D2              * Compare with 70 (highest uppercase hex)
000014A6  6E00 002E                510                  BGT     bound_error         * Error if character is between 70 and 96
000014AA  B43C 0040                511                  CMP.B   #64,D2              * Compare with 64 (lowest uppercase hex)
000014AE  6E00 001A                512                  BGT     uppercase           * Branch to uppercase if above 64
000014B2  B43C 0039                513                  CMP.B   #57,D2              * Compare with 57 (highest decimal number)
000014B6  6E00 001E                514                  BGT     bound_error         * Error if character is between 57 and 64
000014BA  B43C 0030                515                  CMP.B   #48,D2              * Compare with 48 (lowest decimal number)
000014BE  6D00 0016                516                  BLT     bound_error         * Error if character is below 48
000014C2  0402 0030                517                  SUBI.B  #48,D2              * Subtract 48 from ASCII value to get hexadecimal value
000014C6  6000 0006                518                  BRA     decoded             * Translation complete
000014CA                           519                  
000014CA  0402 0037                520  uppercase       SUBI.B  #55,D2              * Subtract 55 from ASCII value to get hexadecimal value
000014CE                           521  
000014CE  E983                     522  decoded         ASL.L   #4,D3               * Clear the return location
000014D0  D602                     523                  ADD.B   D2,D3               * Move the resulting character into the return location
000014D2  60B6                     524                  BRA     translate           * Check next character
000014D4                           525                  
000014D4  4E75                     526  result          RTS                         * Return
000014D6                           527  *////////////////////////////////////////////////////////////////////////////////////////
000014D6                           528  *bound_error: The provided address was out of the valid range, print an error message and ask for
000014D6                           529  * a new one.
000014D6                           530  *////////////////////////////////////////////////////////////////////////////////////////
000014D6  43F9 000015E9            531  bound_error     LEA     input_error,A1      * Assign input error message into A1
000014DC  103C 000E                532                  MOVE.B  #14,D0              * Assign task code for message into D0
000014E0  4E4F                     533                  TRAP    #15                 * Display message
000014E2  4EF8 1010                534                  JMP     get_start           * Prompt for starting address again
000014E6                           535  *////////////////////////////////////////////////////////////////////////////////////////
000014E6                           536  *even_check: Checks whether an address is even, branches to error message if odd.  (Does not change 
000014E6                           537  * address if even).
000014E6                           538  *////////////////////////////////////////////////////////////////////////////////////////
000014E6  4282                     539  even_check      CLR.L   D2                  * Clear D2 for new address
000014E8  7202                     540                  MOVE.L  #$00000002,D1       * Assign value 2 into D1
000014EA  3403                     541                  MOVE.W  D3,D2               * Move address we want to check into D2
000014EC  84C1                     542                  DIVU    D1,D2               * Divide the address by 2
000014EE  4842                     543                  SWAP    D2                  * Swap D2 to find the remainder
000014F0  B43C 0001                544                  CMP.B   #$01,D2             * Check if there is a remainder in D2
000014F4  6700 0004                545                  BEQ     odd_error           * Branch to error if address is odd
000014F8  4E75                     546                  RTS                         * Return
000014FA                           547  *////////////////////////////////////////////////////////////////////////////////////////
000014FA                           548  *odd_error: The provided address was odd, so print an error and return a -1 for the address.
000014FA                           549  *////////////////////////////////////////////////////////////////////////////////////////
000014FA  43F9 00001614            550  odd_error       LEA     not_even,A1         * Assign odd error message to A1
00001500  103C 000E                551                  MOVE.B  #14,D0              * Assign prompt task code to D0
00001504  4E4F                     552                  TRAP    #15                 * Display odd error message
00001506  4686                     553                  NOT.L   D6                  * Assign D6's value to be -1
00001508  2606                     554                  MOVE.L  D6,D3               * Assign the given address to -1
0000150A  4E75                     555                  RTS                         * Return
0000150C                           556  *////////////////////////////////////////////////////////////////////////////////////////
0000150C                           557  *hex_to_ascii: Translates a given HEX value to ASCII for printing
0000150C                           558  *A1: Resulting HEX value
0000150C                           559  *D0: Value to be converted
0000150C                           560  *D1: Size - Number of bytes to be converted
0000150C                           561  *D2: Current character being processed (internal)
0000150C                           562  *D3: Loop counter
0000150C                           563  *////////////////////////////////////////////////////////////////////////////////////////
0000150C  0281 000000FF            564  hex_to_ascii    ANDI.L  #$000000FF,D1       * Isolate the size
00001512  B23C 0004                565                  CMP.B   #4,D1               * Compare the size to 4
00001516  6E00 0048                566                  BGT     hta_error           * Error if the size is > 4
0000151A  B23C 0000                567                  CMP.B   #0,D1               * Compare the size to 0
0000151E  6F00 0040                568                  BLE     hta_error           * Error if the size < 0
00001522  48E7 B000                569                  MOVEM.L D0/D2-D3,-(A7)      * Push the register data onto the stack
00001526  E399                     570                  ROL.L   #1,D1               * Rotate left by 1 to multiply the size by 2
00001528  2601                     571                  MOVE.L  D1,D3               * Save the counter into D3
0000152A                           572                  
0000152A  2400                     573  hta_loop        MOVE.L  D0,D2               * Copy data at D0 into D2
0000152C  0202 000F                574                  ANDI.B  #%00001111,D2       * Select the first ASCII character in D2
00001530  B43C 0009                575                  CMP.B   #9,D2               * Compare the character to 9
00001534  6F00 000A                576                  BLE     hta_number          * Branch to hex number if <= 9
00001538  0642 0037                577                  ADDI    #55,D2              * If letter, add 55 to make it an ASCII value
0000153C  6000 0006                578                  BRA     hta_continue        * Branch to stack operation
00001540                           579                  
00001540  0642 0030                580  hta_number      ADDI    #48,D2              * If number, add 48 to make it an ASCII value
00001544                           581  
00001544  1F02                     582  hta_continue    MOVE.B  D2,-(A7)            * Add the ASCII value to the stack
00001546  E898                     583                  ROR.L   #4,D0               * Rotate right by 4 to get the next character
00001548  5341                     584                  SUBI    #1,D1               * Subtract 1 from the counter
0000154A  B23C 0000                585                  CMP.B   #0,D1               * Compare the counter to 0
0000154E  66DA                     586                  BNE     hta_loop            * Branch to convert the next character if counter is not 0
00001550                           587                  
00001550  12DF                     588  hta_result      MOVE.B  (A7)+,(A1)+         * Retrieve ASCII values from the stack and put them in A1
00001552  5343                     589                  SUBI    #1,D3               * Subtract 1 from the counter
00001554  B63C 0000                590                  CMP.B   #0,D3               * Compare the counter to 0
00001558  66F6                     591                  BNE     hta_result          * Branch to retrieve the next character if counter is not 0
0000155A  4CDF 000D                592                  MOVEM.L (A7)+,D0/D2-D3      * Retrieve original data for the register
0000155E                           593  
0000155E  4E75                     594  hta_finish      RTS                         * Return
00001560                           595  *////////////////////////////////////////////////////////////////////////////////////////
00001560                           596  *odd_error: The provided address was odd, so print an error and return a -1 for the address.
00001560                           597  *////////////////////////////////////////////////////////////////////////////////////////
00001560  43F9 00001650            598  hta_error       LEA     hta_error_msg,A1    * Assign hex to ascii error message into A1
00001566  103C 000E                599                  MOVE.B  #14,D0              * Assign task code for message into D0
0000156A  4E4F                     600                  TRAP    #15                 * Display message
0000156C  4E75                     601                  RTS                         * Return
0000156E                           602  ***************************************************************************************************
0000156E                           603  ***************************************************************************************************
0000156E                           604  *
0000156E                           605  * VARIABLES
0000156E                           606  *
0000156E                           607  ***************************************************************************************************
0000156E                           608  ***************************************************************************************************
0000156E  =0000000D                609  CR              EQU     $0D                 * ASCII code for Carriage Return
0000156E  =0000000A                610  LF              EQU     $0A                 * ASCII code for Line Feed
0000156E= 57 65 6C 63 6F 6D ...    611  greeting        DC.B    'Welcome to EASY68K Disassembler!',CR,LF,0
00001591= 45 6E 74 65 72 20 ...    612  start_prompt    DC.B    'Enter starting address: ($0 to $00FFFFFE)',CR,LF,0
000015BD= 45 6E 74 65 72 20 ...    613  end_prompt      DC.B    'Enter ending address: (start to $00FFFFE)',CR,LF,0
000015E9= 54 68 65 72 65 20 ...    614  input_error     DC.B    'There was something wrong with the input',CR,LF,0
00001614= 54 68 65 20 73 70 ...    615  not_even        DC.B    'The specified address was odd',CR,LF,0
00001634= 41 6C 6C 20 64 6F ...    616  end_message     DC.B    'All done!  See you later!',CR,LF,0
00001650= 54 68 65 20 6E 75 ...    617  hta_error_msg   DC.B    'The number of bytes was incorrect',CR,LF,0
00001674                           618  buffer          DS.B    80
000016C4                           619  start_input     DS.B    80
00001714                           620  end_input       DS.B    80
00001764                           621  
00001764                           622  
00001764                           623      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_TO_HEX        1470
BEGIN               0
BOUND_ERROR         14D6
BUFFER              1674
CODE0000            1178
CODE0001            117C
CODE0010            11CE
CODE0011            121E
CODE0100            126E
CODE0101            1272
CODE0110            1276
CODE0111            127A
CODE1000            127E
CODE1001            1282
CODE1010            1286
CODE1011            128A
CODE1100            128E
CODE1101            1292
CODE1110            1296
CODE1111            129A
CR                  D
CURRENT             0
DATA_ERROR          12AE
DECODED             14CE
EAMODE              12E8
EAMODE0             1328
EAMODE1             1334
EAMODE2             1340
EAMODE3             1354
EAMODE4             136C
EAMODE5             1384
EAMODE6             13C2
EAMODE7             1400
END                 FFFFFE
END_CHECK           12D8
END_INPUT           1714
END_MESSAGE         1634
END_PROMPT          15BD
EVEN_CHECK          14E6
GET_BYTE            1418
GET_END             1050
GET_LONG            1444
GET_START           1010
GET_WORD            142E
GREETING            156E
HEX_TO_ASCII        150C
HTA_CONTINUE        1544
HTA_ERROR           1560
HTA_ERROR_MSG       1650
HTA_FINISH          155E
HTA_LOOP            152A
HTA_NUMBER          1540
HTA_RESULT          1550
IMMEDIATE_DATA      145A
INPUT_ERROR         15E9
IS_MOVEA            12A8
JMP_TABLE           1118
LF                  A
MAIN                108E
MOVEA_CHECK         129E
NOT_EVEN            1614
ODD_ERROR           14FA
OP_CODE             10C6
PRINT               10AC
RESULT              14D4
SHIFT               C
STACK               7000
START               1000
START_INPUT         16C4
START_PROMPT        1591
TRANSLATE           148A
UPPERCASE           14CA
