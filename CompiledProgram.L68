00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.01
Created On: 5/24/2014 10:30:36 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Derek Willms, Binh Nguyen, Brian Quigley
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00000000                             7      
00000000  =00000000                  8  begin           EQU     $00000000
00000000  =00FFFFFE                  9  end             EQU     $00FFFFFE
00000000  =00007000                 10  stack           EQU     $7000               * Stack address
00000000  =0000000C                 11  shift           EQU     12                  * Shift 12 bits
00000000                            12  
00000000= 0001                      13  current         DC.W    1
00000002                            14                  
00001000                            15  START:          ORG     $1000
00001000                            16  
00001000  4FF8 7000                 17  start           LEA     stack,SP            * Load the Stack Pointer
00001004  43F9 0000154E             18                  LEA     greeting,A1         * Assign greeting to A1
0000100A  103C 000E                 19                  MOVE.B  #14,D0              * Assign prompt task code to D0
0000100E  4E4F                      20                  TRAP    #15                 * Display greeting
00001010                            21                  
00001010  43F9 00001571             22  get_start       LEA     start_prompt,A1     * Assign starting address prompt to A1
00001016  103C 000E                 23                  MOVE.B  #14,D0              * Assign prompt task code to D0
0000101A  4E4F                      24                  TRAP    #15                 * Display starting address prompt
0000101C                            25                  
0000101C  43F9 000016A4             26                  LEA     start_input,A1      * Assign start_input as address to store input
00001022  103C 0002                 27                  MOVE.B  #2,D0               * Assign input task code to D0
00001026  4E4F                      28                  TRAP    #15                 * Store user input in A1
00001028                            29                  
00001028  4EB9 00001450             30                  JSR     ascii_to_hex        * Translate ASCII input to HEX
0000102E  4EB9 000014C6             31                  JSR     even_check          * Check if given address is odd
00001034  B67C FFFF                 32                  CMP.W   #-1,D3              * Check result of odd check
00001038  67D6                      33                  BEQ     get_start           * If odd, display an error and ask for new starting address
0000103A                            34                  
0000103A  7A00                      35                  MOVE.L  #begin,D5           * Assign minimum address bound to D5
0000103C  B685                      36                  CMP.L   D5,D3               * Compare address to minimum bound
0000103E  6D00 0476                 37                  BLT     bound_error         * Error if address is below minimum
00001042  2A3C 00FFFFFE             38                  MOVE.L  #end,D5             * Assign maximum address bound to D5
00001048  B685                      39                  CMP.L   D5,D3               * Compare address to maximum bound
0000104A  6E00 046A                 40                  BGT     bound_error         * Error if address is above maximum
0000104E  2C43                      41                  MOVEA.L D3,A6               * Save the lower address into A6
00001050                            42                  
00001050  43F9 0000159D             43  get_end         LEA     end_prompt,A1       * Assign ending address prompt to A1
00001056  103C 000E                 44                  MOVE.B  #14,D0              * Assign prompt task code to D0
0000105A  4E4F                      45                  TRAP    #15                 * Display ending address prompt
0000105C                            46                  
0000105C  43F9 000016F4             47                  LEA     end_input,A1        * Assign end_input as address to store input
00001062  103C 0002                 48                  MOVE.B  #2,D0               * Assign input task code to D0
00001066  4E4F                      49                  TRAP    #15                 * Store user input in A1
00001068                            50                  
00001068  4EB9 00001450             51                  JSR     ascii_to_hex        * Translate ASCII input to HEX
0000106E  4EB9 000014C6             52                  JSR     even_check          * Check if given address is odd
00001074  B67C FFFF                 53                  CMP.W   #-1,D3              * Check result of odd check
00001078  67D6                      54                  BEQ     get_end             * If odd, display an error and ask for new starting address
0000107A                            55                  
0000107A  B68E                      56                  CMP.L   A6,D3               * Compare address to lower address
0000107C  6D00 0438                 57                  BLT     bound_error         * Error if address is below lower address
00001080  B685                      58                  CMP.L   D5,D3               * Compare address to maximum bound
00001082  6E00 0432                 59                  BGT     bound_error         * Error if address is above maximum
00001086  2C03                      60                  MOVE.L  D3,D6               * Save the upper address into D6
00001088                            61                  
00001088  4282                      62                  CLR.L   D2                  * Clear D2
0000108A  4283                      63                  CLR.L   D3                  * Clear D3
0000108C  4285                      64                  CLR.L   D5                  * Clear D5
0000108E                            65                  
0000108E                            66  
0000108E  4280                      67  main            CLR.L   D0                  * Clear D0
00001090  4281                      68                  CLR.L   D1                  * Clear D1
00001092  200E                      69                  MOVE.L  A6,D0               * Get current memory pointer in D0
00001094  123C 0004                 70                  MOVE.B  #4,D1               * Size for address is 4 bytes
00001098  227C 00001654             71                  MOVE.L  #buffer,A1          * Set A1 to point to the print buffer
0000109E  4EB9 000014EC             72                  JSR     hex_to_ascii        * Translate hex to ascii
000010A4  12FC 0009                 73                  MOVE.B  #$9,(A1)+           * Add a tab
000010A8                            74                  
000010A8  6000 001C                 75                  BRA     op_code             * Begin decode 
000010AC                            76                  
000010AC                            77  Print           
000010AC  12BC 0000                 78                  MOVE.B  #$00,(A1)            * Add terminator              
000010B0  4280                      79                  CLR.L   D0                   * Clear D0   
000010B2  103C 000D                 80                  MOVE.B  #13,D0               * Load Trap task number 13 for printing
000010B6  43F9 00001654             81                  LEA     buffer,A1            * Load print buffer into A1 
000010BC  4E4F                      82                  TRAP    #15                  * Print the buffer
000010BE                            83                  
000010BE  BC8E                      84                  CMP.L   A6,D6                * Compare current memory pointer with ending address 
000010C0  6F00 01F6                 85                  BLE     end_check            * Less than equal zero, reach the end
000010C4  60C8                      86                  BRA     main                 * Go to next memory
000010C6                            87  
000010C6                            88  *////////////////////////////////////////////////////////////////////////////////////////
000010C6                            89  *op_code: get the data from current memory pointer, advance the memory pointer, separate 
000010C6                            90  *         the bits, and jump to the corresponding op_code decoding
000010C6                            91  *D0: Internal 
000010C6                            92  *D1: Internal
000010C6                            93  *D2: Store 3 bits for Source REGISTER
000010C6                            94  *D3: Store 3 bits for Source MODE
000010C6                            95  *D4: Store 3 bits for Destination MODE
000010C6                            96  *D5: Store 3 bits for Destination REGISTER
000010C6                            97  *current: Store the WORD data
000010C6                            98  *////////////////////////////////////////////////////////////////////////////////////////                
000010C6  41F9 00001118             99  op_code         LEA     jmp_table,A0                    *Index into the table
000010CC  4280                     100                  CLR.L   D0                              *Zero it
000010CE                           101                  
000010CE  31DE 0000                102                  MOVE.W  (A6)+,current                   *Get WORD and advance memory pointer                
000010D2  3038 0000                103                  MOVE.W  current,D0                      *Copy WORD to D0            
000010D6  3200                     104                  MOVE.W  D0,D1                           *Copy Word data to D1
000010D8  48E7 8000                105                  MOVEM.L D0,-(SP)                        *Copy Word data to the stack
000010DC                           106      
000010DC  0241 0007                107                  ANDI.W  #%0000000000000111,D1           *Get last 3 bits Source REG
000010E0  1401                     108                  MOVE.B  D1,D2                           *Store in D2
000010E2                           109      
000010E2  E658                     110                  ROR.W   #3,D0                           *Rotate D0 right 3 bits
000010E4  3200                     111                  MOVE.W  D0,D1                           *Copy Word to D1
000010E6  0241 0007                112                  ANDI.W  #%0000000000000111,D1           *Get last 3 bits Source MODE
000010EA  1601                     113                  MOVE.B  D1,D3                           *Store in D3
000010EC                           114      
000010EC  E658                     115                  ROR.W   #3,D0                           *Rotate D0 right 3 bits
000010EE  3200                     116                  MOVE.W  D0,D1                           *Copy Word to D1
000010F0  0241 0007                117                  ANDI.W  #%0000000000000111,D1           *Get last 3 bits Dest MODE
000010F4  1801                     118                  MOVE.B  D1,D4                           *Store in D4
000010F6                           119      
000010F6  E658                     120                  ROR.W   #3,D0                           *Rotate D0 right 3 bits
000010F8  3200                     121                  MOVE.W  D0,D1                           *Copy Word to D1
000010FA  0241 0007                122                  ANDI.W  #%0000000000000111,D1           *Get last 3 bits Dest REG
000010FE  1A01                     123                  MOVE.B  D1,D5                           *Store in D5
00001100                           124      
00001100  4CDF 0001                125                  MOVEM.L (SP)+,D0                        *Pop Word data from stack to D0
00001104  4281                     126                  CLR.L   D1                              *Clear D1
00001106                           127  
00001106  123C 000C                128                  MOVE.B  #shift,D1                       *Shift 12 bits to the right 
0000110A  E268                     129                  LSR.W   D1,D0                           *Move the bits
0000110C                           130      
0000110C  4281                     131                  CLR.L   D1                              *Clear D1
0000110E  1200                     132                  MOVE.B  D0,D1                           *Copy 4 bits to D1
00001110                           133      
00001110  C0FC 0006                134                  MULU    #6,D0                           *Form offset
00001114  4EB0 0000                135                  JSR     0(A0,D0)                        *Jump indirect with index
00001118                           136  
00001118                           137  jmp_table
00001118  4EF9 00001178            138      JMP     code0000                        *Bit manipulation/MOVEP/Immediate
0000111E  4EF9 0000117C            139      JMP     code0001                        *Move Byte
00001124  4EF9 000011CE            140      JMP     code0010                        *Move Long
0000112A  4EF9 00001220            141      JMP     code0011                        *Move Word
00001130  4EF9 00001272            142      JMP     code0100                        *Miscellaneous
00001136  4EF9 00001276            143      JMP     code0101                        *ADDQ/SUBQ/Scc/DBcc
0000113C  4EF9 0000127A            144      JMP     code0110                        *BSR,BRA,Bcc
00001142  4EF9 0000127E            145      JMP     code0111                        *MOVEQ
00001148  4EF9 00001282            146      JMP     code1000                        *OR/DIV/SBCD
0000114E  4EF9 00001286            147      JMP     code1001                        *SUB/SUBX
00001154  4EF9 0000128A            148      JMP     code1010                        *Unassigned
0000115A  4EF9 0000128E            149      JMP     code1011                        *CMP/EOR
00001160  4EF9 00001292            150      JMP     code1100                        *AND/MUL/ABCD/EXG
00001166  4EF9 00001296            151      JMP     code1101                        *ADD/ADDA/ADDX
0000116C  4EF9 0000129A            152      JMP     code1110                        *Shift/Rotate
00001172  4EF9 0000129E            153      JMP     code1111                        *Special/Reserved
00001178                           154      
00001178  4E72 2700                155  code0000    STOP    #$2700
0000117C                           156  
0000117C                           157  *////////////////////////////////////////////////////////////////////////////////////////
0000117C                           158  *code0001: MOVE.B 
0000117C                           159  *////////////////////////////////////////////////////////////////////////////////////////  
0000117C                           160  code0001
0000117C  12FC 004D                161      MOVE.B  #'M',(A1)+
00001180  12FC 004F                162      MOVE.B  #'O',(A1)+
00001184  12FC 0056                163      MOVE.B  #'V',(A1)+
00001188  12FC 0045                164      MOVE.B  #'E',(A1)+
0000118C  12FC 002E                165      MOVE.B  #'.',(A1)+
00001190  12FC 0042                166      MOVE.B  #'B',(A1)+
00001194  12FC 0020                167      MOVE.B  #' ',(A1)+
00001198  12FC 0020                168      MOVE.B  #' ',(A1)+
0000119C  12FC 0020                169      MOVE.B  #' ',(A1)+
000011A0  12FC 0020                170      MOVE.B  #' ',(A1)+
000011A4                           171      
000011A4  4280                     172      CLR.L   D0                              *Clear D0
000011A6  103C 0001                173      MOVE.B  #1,D0                           *size is 1 byte
000011AA                           174      
000011AA                           175         
000011AA  4EB9 000012C8            176      JSR     EAMode                          *Jump to EAMode
000011B0                           177      
000011B0  12FC 002C                178      MOVE.B  #',',(A1)+
000011B4                           179      
000011B4  4282                     180      CLR.L   D2
000011B6  4283                     181      CLR.L   D3
000011B8  1604                     182      MOVE.B  D4,D3                           *Get Destination MODE
000011BA  1405                     183      MOVE.B  D5,D2                           *Get Source REG
000011BC                           184      
000011BC  B63C 0001                185      CMP.B   #1,D3                           *An not allowed
000011C0  6700 00E0                186      BEQ     data_error
000011C4                           187  
000011C4                           188      
000011C4  4EB9 000012C8            189      JSR     EAMode                          *Jump to EAMode
000011CA                           190      
000011CA  6000 FEE0                191      BRA     Print
000011CE                           192  
000011CE                           193  *////////////////////////////////////////////////////////////////////////////////////////
000011CE                           194  *code0001: MOVE.L 
000011CE                           195  *//////////////////////////////////////////////////////////////////////////////////////// 
000011CE                           196  code0010    
000011CE  12FC 004D                197      MOVE.B  #'M',(A1)+
000011D2  12FC 004F                198      MOVE.B  #'O',(A1)+
000011D6  12FC 0056                199      MOVE.B  #'V',(A1)+
000011DA  12FC 0045                200      MOVE.B  #'E',(A1)+
000011DE  12FC 002E                201      MOVE.B  #'.',(A1)+
000011E2  12FC 004C                202      MOVE.B  #'L',(A1)+
000011E6  12FC 0020                203      MOVE.B  #' ',(A1)+
000011EA  12FC 0020                204      MOVE.B  #' ',(A1)+
000011EE  12FC 0020                205      MOVE.B  #' ',(A1)+
000011F2  12FC 0020                206      MOVE.B  #' ',(A1)+
000011F6                           207      
000011F6  4280                     208      CLR.L   D0                              *Clear D0
000011F8  103C 0004                209      MOVE.B  #4,D0                           *size is 4 bytes
000011FC                           210      
000011FC                           211         
000011FC  4EB9 000012C8            212      JSR     EAMode                          *Jump to EAMode
00001202                           213      
00001202  12FC 002C                214      MOVE.B  #',',(A1)+
00001206                           215      
00001206  4282                     216      CLR.L   D2
00001208  4283                     217      CLR.L   D3
0000120A  1604                     218      MOVE.B  D4,D3                           *Get Destination MODE
0000120C  1405                     219      MOVE.B  D5,D2                           *Get Source REG
0000120E                           220      
0000120E  B63C 0001                221      CMP.B   #1,D3                           *An not allowed
00001212  6700 008E                222      BEQ     data_error
00001216                           223  
00001216                           224      
00001216  4EB9 000012C8            225      JSR     EAMode                          *Jump to EAMode
0000121C                           226      
0000121C  6000 FE8E                227      BRA     Print
00001220                           228  
00001220                           229  
00001220                           230  *////////////////////////////////////////////////////////////////////////////////////////
00001220                           231  *code0011: MOVE.W 
00001220                           232  *//////////////////////////////////////////////////////////////////////////////////////// 
00001220                           233  code0011    
00001220  12FC 004D                234      MOVE.B  #'M',(A1)+
00001224  12FC 004F                235      MOVE.B  #'O',(A1)+
00001228  12FC 0056                236      MOVE.B  #'V',(A1)+
0000122C  12FC 0045                237      MOVE.B  #'E',(A1)+
00001230  12FC 002E                238      MOVE.B  #'.',(A1)+
00001234  12FC 0057                239      MOVE.B  #'W',(A1)+
00001238  12FC 0020                240      MOVE.B  #' ',(A1)+
0000123C  12FC 0020                241      MOVE.B  #' ',(A1)+
00001240  12FC 0020                242      MOVE.B  #' ',(A1)+
00001244  12FC 0020                243      MOVE.B  #' ',(A1)+
00001248                           244      
00001248  4280                     245      CLR.L   D0                              *Clear D0
0000124A  103C 0002                246      MOVE.B  #2,D0                           *size is 2 bytes
0000124E                           247      
0000124E                           248         
0000124E  4EB9 000012C8            249      JSR     EAMode                          *Jump to EAMode
00001254                           250      
00001254  12FC 002C                251      MOVE.B  #',',(A1)+
00001258                           252      
00001258  4282                     253      CLR.L   D2
0000125A  4283                     254      CLR.L   D3
0000125C  1604                     255      MOVE.B  D4,D3                           *Get Destination MODE
0000125E  1405                     256      MOVE.B  D5,D2                           *Get Source REG
00001260                           257      
00001260  B63C 0001                258      CMP.B   #1,D3                           *An not allowed
00001264  6700 003C                259      BEQ     data_error
00001268                           260  
00001268                           261      
00001268  4EB9 000012C8            262      JSR     EAMode                          *Jump to EAMode
0000126E                           263      
0000126E  6000 FE3C                264      BRA     Print
00001272                           265  
00001272                           266  
00001272  4E72 2700                267  code0100    STOP    #$2700
00001276                           268  
00001276  4E72 2700                269  code0101    STOP    #$2700
0000127A  4E72 2700                270  code0110    STOP    #$2700
0000127E  4E72 2700                271  code0111    STOP    #$2700
00001282  4E72 2700                272  code1000    STOP    #$2700
00001286  4E72 2700                273  code1001    STOP    #$2700
0000128A  4E72 2700                274  code1010    STOP    #$2700
0000128E  4E72 2700                275  code1011    STOP    #$2700
00001292  4E72 2700                276  code1100    STOP    #$2700
00001296  4E72 2700                277  code1101    STOP    #$2700
0000129A  4E72 2700                278  code1110    STOP    #$2700
0000129E  6000 0002                279  code1111    BRA     data_error
000012A2                           280  
000012A2                           281  
000012A2                           282  data_error
000012A2  4280                     283                  CLR.L   D0
000012A4  3038 0000                284                  MOVE.W  current,D0
000012A8  4281                     285                  CLR.L   D1
000012AA  123C 0002                286                  MOVE.B  #2,D1
000012AE                           287                 
000012AE  4EB9 000014EC            288                  JSR     hex_to_ascii
000012B4  6000 FDF6                289                  BRA     Print
000012B8                           290  
000012B8                           291  
000012B8                           292      
000012B8                           293  end_check       
000012B8                           294                  
000012B8  43F9 00001614            295                  LEA     end_message,A1      * Assign end message to A1
000012BE  103C 000E                296                  MOVE.B  #14,D0              * Assign prompt task code to D0
000012C2  4E4F                     297                  TRAP    #15                 * Display end message
000012C4  4E72 2700                298                  STOP    #$00002700          * Stop                
000012C8                           299  
000012C8                           300  ***************************************************************************************************
000012C8                           301  ***************************************************************************************************
000012C8                           302  *
000012C8                           303  * SUBROUTINES
000012C8                           304  *
000012C8                           305  ***************************************************************************************************
000012C8                           306  ***************************************************************************************************
000012C8                           307  
000012C8                           308  *////////////////////////////////////////////////////////////////////////////////////////
000012C8                           309  *EAMode: take in the 6 bits EA and branch to the corresponding EA mode
000012C8                           310  *D0: byte size for immediate data
000012C8                           311  *D3: the 3 bits EA MODE
000012C8                           312  *D4: the 3 bits EA REG
000012C8                           313  *//////////////////////////////////////////////////////////////////////////////////////// 
000012C8                           314  EAMode
000012C8  B63C 0000                315      CMP.B   #0,D3
000012CC  6700 003A                316      BEQ     EAmode0
000012D0  B63C 0001                317      CMP.B   #1,D3
000012D4  6700 003E                318      BEQ     EAmode1
000012D8  B63C 0002                319      CMP.B   #2,D3
000012DC  6700 0042                320      BEQ     EAmode2
000012E0  B63C 0003                321      CMP.B   #3,D3
000012E4  6700 004E                322      BEQ     EAmode3
000012E8  B63C 0004                323      CMP.B   #4,D3
000012EC  6700 005E                324      BEQ     EAmode4
000012F0  B63C 0005                325      CMP.B   #5,D3
000012F4  6700 006E                326      BEQ     EAmode5
000012F8  B63C 0006                327      CMP.B   #6,D3
000012FC  6700 00A4                328      BEQ     EAmode6
00001300  B63C 0007                329      CMP.B   #7,D3
00001304  6700 00DA                330      BEQ     EAmode7    
00001308                           331        
00001308                           332  EAmode0
00001308  12FC 0044                333      MOVE.B  #'D',(A1)+                  
0000130C  0642 0030                334      ADD     #$30,D2                         *Convert REG# to ASCII
00001310  12C2                     335      MOVE.B  D2,(A1)+                        *Add to buffer
00001312                           336  
00001312  4E75                     337      RTS    
00001314                           338      
00001314                           339  EAmode1
00001314  12FC 0041                340      MOVE.B  #'A',(A1)+                  
00001318  0642 0030                341      ADD     #$30,D2                         *Convert REG# to ASCII
0000131C  12C2                     342      MOVE.B  D2,(A1)+                        *Add to buffer
0000131E                           343      
0000131E  4E75                     344      RTS
00001320                           345  
00001320                           346  EAmode2
00001320  12FC 0028                347      MOVE.B  #'(',(A1)+
00001324  12FC 0041                348      MOVE.B  #'A',(A1)+                  
00001328  0642 0030                349      ADD     #$30,D2                         *Convert REG# to ASCII
0000132C  12C2                     350      MOVE.B  D2,(A1)+                        *Add to buffer
0000132E  12FC 0029                351      MOVE.B  #')',(A1)+
00001332                           352  
00001332  4E75                     353      RTS
00001334                           354  
00001334                           355  EAmode3
00001334  12FC 0028                356      MOVE.B  #'(',(A1)+
00001338  12FC 0041                357      MOVE.B  #'A',(A1)+                  
0000133C  0642 0030                358      ADD     #$30,D2                         *Convert REG# to ASCII
00001340  12C2                     359      MOVE.B  D2,(A1)+                        *Add to buffer
00001342  12FC 0029                360      MOVE.B  #')',(A1)+
00001346  12FC 002B                361      MOVE.B  #'+',(A1)+
0000134A                           362  
0000134A  4E75                     363      RTS
0000134C                           364  
0000134C                           365  EAmode4
0000134C  12FC 002D                366      MOVE.B  #'-',(A1)+
00001350  12FC 0028                367      MOVE.B  #'(',(A1)+
00001354  12FC 0041                368      MOVE.B  #'A',(A1)+                  
00001358  0642 0030                369      ADD     #$30,D2                         *Convert REG# to ASCII
0000135C  12C2                     370      MOVE.B  D2,(A1)+                        *Add to buffer
0000135E  12FC 0029                371      MOVE.B  #')',(A1)+
00001362                           372  
00001362  4E75                     373      RTS
00001364                           374  
00001364                           375  EAmode5
00001364  12FC 0049                376      MOVE.B  #'I',(A1)+
00001368  12FC 004E                377      MOVE.B  #'N',(A1)+
0000136C  12FC 0056                378      MOVE.B  #'V',(A1)+
00001370  12FC 0041                379      MOVE.B  #'A',(A1)+
00001374  12FC 004C                380      MOVE.B  #'L',(A1)+
00001378  12FC 0049                381      MOVE.B  #'I',(A1)+
0000137C  12FC 0044                382      MOVE.B  #'D',(A1)+
00001380  12FC 0020                383      MOVE.B  #' ',(A1)+
00001384  12FC 0045                384      MOVE.B  #'E',(A1)+
00001388  12FC 0041                385      MOVE.B  #'A',(A1)+
0000138C  12FC 0020                386      MOVE.B  #' ',(A1)+
00001390  12FC 004D                387      MOVE.B  #'M',(A1)+
00001394  12FC 004F                388      MOVE.B  #'O',(A1)+
00001398  12FC 0044                389      MOVE.B  #'D',(A1)+
0000139C  12FC 0045                390      MOVE.B  #'E',(A1)+
000013A0                           391  
000013A0  4E75                     392      RTS    
000013A2                           393   
000013A2                           394  EAmode6
000013A2  12FC 0049                395      MOVE.B  #'I',(A1)+
000013A6  12FC 004E                396      MOVE.B  #'N',(A1)+
000013AA  12FC 0056                397      MOVE.B  #'V',(A1)+
000013AE  12FC 0041                398      MOVE.B  #'A',(A1)+
000013B2  12FC 004C                399      MOVE.B  #'L',(A1)+
000013B6  12FC 0049                400      MOVE.B  #'I',(A1)+
000013BA  12FC 0044                401      MOVE.B  #'D',(A1)+
000013BE  12FC 0020                402      MOVE.B  #' ',(A1)+
000013C2  12FC 0045                403      MOVE.B  #'E',(A1)+
000013C6  12FC 0041                404      MOVE.B  #'A',(A1)+
000013CA  12FC 0020                405      MOVE.B  #' ',(A1)+
000013CE  12FC 004D                406      MOVE.B  #'M',(A1)+
000013D2  12FC 004F                407      MOVE.B  #'O',(A1)+
000013D6  12FC 0044                408      MOVE.B  #'D',(A1)+
000013DA  12FC 0045                409      MOVE.B  #'E',(A1)+
000013DE                           410  
000013DE  4E75                     411      RTS
000013E0                           412  
000013E0                           413  EAmode7
000013E0  B43C 0000                414      CMP.B   #0,D2                           *WORD addressing mode
000013E4  6700 0028                415      BEQ     get_word  
000013E8                           416    
000013E8  B43C 0001                417      CMP.B   #1,D2                           *LONG WORD addressing mode        
000013EC  6700 0036                418      BEQ     get_long                   
000013F0                           419      
000013F0  B43C 0004                420      CMP.B   #4,D2                           *IMMEDIATE DATA addressing mode
000013F4  6700 0044                421      BEQ     IMMEDIATE_DATA
000013F8                           422  
000013F8                           423  get_byte
000013F8  12FC 0024                424      MOVE.B  #'$',(A1)+    
000013FC  4280                     425      CLR.L   D0                              *Clear D0
000013FE  301E                     426      MOVE.W  (A6)+,D0                        *Get next WORD from memory
00001400  4281                     427      CLR.L   D1                              *Clear D1
00001402  123C 0001                428      MOVE.B  #1,D1                           *Byte size is 1  
00001406                           429      
00001406  4EB9 000014EC            430      JSR     hex_to_ascii
0000140C                           431      
0000140C  4E75                     432      RTS
0000140E                           433  
0000140E                           434  get_word
0000140E  12FC 0024                435      MOVE.B  #'$',(A1)+    
00001412  4280                     436      CLR.L   D0                              *Clear D0
00001414  301E                     437      MOVE.W  (A6)+,D0                        *Get next WORD from memory
00001416  4281                     438      CLR.L   D1                              *Clear D1
00001418  123C 0002                439      MOVE.B  #2,D1                           *Byte size is 2  
0000141C                           440      
0000141C  4EB9 000014EC            441      JSR     hex_to_ascii
00001422                           442      
00001422  4E75                     443      RTS
00001424                           444      
00001424                           445      
00001424                           446  get_long
00001424  12FC 0024                447      MOVE.B  #'$',(A1)+
00001428  4280                     448      CLR.L   D0                              *Clear D0
0000142A  201E                     449      MOVE.L  (A6)+,D0                        *Get next LONG WORD from memory
0000142C  4281                     450      CLR.L   D1                              *Clear D1
0000142E  123C 0004                451      MOVE.B  #4,D1                           *Byte size is 4
00001432                           452      
00001432  4EB9 000014EC            453      JSR     hex_to_ascii 
00001438                           454  
00001438  4E75                     455      RTS
0000143A                           456  
0000143A                           457  immediate_data    
0000143A  12FC 0023                458      MOVE.B  #'#',(A1)+
0000143E  B03C 0002                459      CMP.B   #2,D0                           *Is the size WORD
00001442  67CA                     460      BEQ     get_word    
00001444  B03C 0004                461      CMP.B   #4,D0                           *Is the size LONG WORD
00001448  67DA                     462      BEQ     get_long
0000144A  B03C 0001                463      CMP.B   #1,D0                           *Is the size BYTE
0000144E  67A8                     464      BEQ     get_byte
00001450                           465  
00001450                           466  
00001450                           467  *////////////////////////////////////////////////////////////////////////////////////////
00001450                           468  *ascii_to_hex: transforms ASCII input into a hexadecimal address, returns error if invalid characters
00001450                           469  *D1: ASCII parameter to be converted
00001450                           470  *D2: Internal data used for comparison
00001450                           471  *D3: Return data
00001450                           472  *D6: Internal data used for NULL comparison
00001450                           473  *////////////////////////////////////////////////////////////////////////////////////////
00001450  7C00                     474  ascii_to_hex    MOVEQ   #$0,D6              * Clear D6 for null comparison
00001452  7600                     475                  MOVEQ   #$0,D3              * Clear D3 for new data
00001454  B203                     476                  CMP.B   D3,D1               * Null check on string
00001456  6700 005E                477                  BEQ     bound_error         * Error if null
0000145A  0C41 0000                478                  CMPI    #$0,D1              * Character check on string
0000145E  6F00 0056                479                  BLE     bound_error         * Error if less than 0
00001462  0C41 0008                480                  CMPI    #$8,D1              * Character check on string
00001466  6E00 004E                481                  BGT     bound_error         * Error if more than 8 characters
0000146A                           482                  
0000146A  1419                     483  translate       MOVE.B  (A1)+,D2            * Move next character into D2
0000146C  B406                     484                  CMP.B   D6,D2               * Null check on character
0000146E  6700 0044                485                  BEQ     result              * End of input if null
00001472  B43C 0066                486                  CMP.B   #102,D2             * Compare with 102 (highest character code)
00001476  6E00 003E                487                  BGT     bound_error         * Error if character is higher than 102
0000147A  B43C 0060                488                  CMP.B   #96,D2              * Compare with 96 (lowest lowercase hex)
0000147E  6E00 0036                489                  BGT     bound_error         * Error if character is lowercase
00001482  B43C 0046                490                  CMP.B   #70,D2              * Compare with 70 (highest uppercase hex)
00001486  6E00 002E                491                  BGT     bound_error         * Error if character is between 70 and 96
0000148A  B43C 0040                492                  CMP.B   #64,D2              * Compare with 64 (lowest uppercase hex)
0000148E  6E00 001A                493                  BGT     uppercase           * Branch to uppercase if above 64
00001492  B43C 0039                494                  CMP.B   #57,D2              * Compare with 57 (highest decimal number)
00001496  6E00 001E                495                  BGT     bound_error         * Error if character is between 57 and 64
0000149A  B43C 0030                496                  CMP.B   #48,D2              * Compare with 48 (lowest decimal number)
0000149E  6D00 0016                497                  BLT     bound_error         * Error if character is below 48
000014A2  0402 0030                498                  SUBI.B  #48,D2              * Subtract 48 from ASCII value to get hexadecimal value
000014A6  6000 0006                499                  BRA     decoded             * Translation complete
000014AA                           500                  
000014AA  0402 0037                501  uppercase       SUBI.B  #55,D2              * Subtract 55 from ASCII value to get hexadecimal value
000014AE                           502  
000014AE  E983                     503  decoded         ASL.L   #4,D3               * Clear the return location
000014B0  D602                     504                  ADD.B   D2,D3               * Move the resulting character into the return location
000014B2  60B6                     505                  BRA     translate           * Check next character
000014B4                           506                  
000014B4  4E75                     507  result          RTS                         * Return
000014B6                           508  *////////////////////////////////////////////////////////////////////////////////////////
000014B6                           509  *bound_error: The provided address was out of the valid range, print an error message and ask for
000014B6                           510  * a new one.
000014B6                           511  *////////////////////////////////////////////////////////////////////////////////////////
000014B6  43F9 000015C9            512  bound_error     LEA     input_error,A1      * Assign input error message into A1
000014BC  103C 000E                513                  MOVE.B  #14,D0              * Assign task code for message into D0
000014C0  4E4F                     514                  TRAP    #15                 * Display message
000014C2  4EF8 1010                515                  JMP     get_start           * Prompt for starting address again
000014C6                           516  *////////////////////////////////////////////////////////////////////////////////////////
000014C6                           517  *even_check: Checks whether an address is even, branches to error message if odd.  (Does not change 
000014C6                           518  * address if even).
000014C6                           519  *////////////////////////////////////////////////////////////////////////////////////////
000014C6  4282                     520  even_check      CLR.L   D2                  * Clear D2 for new address
000014C8  7202                     521                  MOVE.L  #$00000002,D1       * Assign value 2 into D1
000014CA  3403                     522                  MOVE.W  D3,D2               * Move address we want to check into D2
000014CC  84C1                     523                  DIVU    D1,D2               * Divide the address by 2
000014CE  4842                     524                  SWAP    D2                  * Swap D2 to find the remainder
000014D0  B43C 0001                525                  CMP.B   #$01,D2             * Check if there is a remainder in D2
000014D4  6700 0004                526                  BEQ     odd_error           * Branch to error if address is odd
000014D8  4E75                     527                  RTS                         * Return
000014DA                           528  *////////////////////////////////////////////////////////////////////////////////////////
000014DA                           529  *odd_error: The provided address was odd, so print an error and return a -1 for the address.
000014DA                           530  *////////////////////////////////////////////////////////////////////////////////////////
000014DA  43F9 000015F4            531  odd_error       LEA     not_even,A1         * Assign odd error message to A1
000014E0  103C 000E                532                  MOVE.B  #14,D0              * Assign prompt task code to D0
000014E4  4E4F                     533                  TRAP    #15                 * Display odd error message
000014E6  4686                     534                  NOT.L   D6                  * Assign D6's value to be -1
000014E8  2606                     535                  MOVE.L  D6,D3               * Assign the given address to -1
000014EA  4E75                     536                  RTS                         * Return
000014EC                           537  *////////////////////////////////////////////////////////////////////////////////////////
000014EC                           538  *hex_to_ascii: Translates a given HEX value to ASCII for printing
000014EC                           539  *A1: Resulting HEX value
000014EC                           540  *D0: Value to be converted
000014EC                           541  *D1: Size - Number of bytes to be converted
000014EC                           542  *D2: Current character being processed (internal)
000014EC                           543  *D3: Loop counter
000014EC                           544  *////////////////////////////////////////////////////////////////////////////////////////
000014EC  0281 000000FF            545  hex_to_ascii    ANDI.L  #$000000FF,D1       * Isolate the size
000014F2  B23C 0004                546                  CMP.B   #4,D1               * Compare the size to 4
000014F6  6E00 0048                547                  BGT     hta_error           * Error if the size is > 4
000014FA  B23C 0000                548                  CMP.B   #0,D1               * Compare the size to 0
000014FE  6F00 0040                549                  BLE     hta_error           * Error if the size < 0
00001502  48E7 B000                550                  MOVEM.L D0/D2-D3,-(A7)      * Push the register data onto the stack
00001506  E399                     551                  ROL.L   #1,D1               * Rotate left by 1 to multiply the size by 2
00001508  2601                     552                  MOVE.L  D1,D3               * Save the counter into D3
0000150A                           553                  
0000150A  2400                     554  hta_loop        MOVE.L  D0,D2               * Copy data at D0 into D2
0000150C  0202 000F                555                  ANDI.B  #%00001111,D2       * Select the first ASCII character in D2
00001510  B43C 0009                556                  CMP.B   #9,D2               * Compare the character to 9
00001514  6F00 000A                557                  BLE     hta_number          * Branch to hex number if <= 9
00001518  0642 0037                558                  ADDI    #55,D2              * If letter, add 55 to make it an ASCII value
0000151C  6000 0006                559                  BRA     hta_continue        * Branch to stack operation
00001520                           560                  
00001520  0642 0030                561  hta_number      ADDI    #48,D2              * If number, add 48 to make it an ASCII value
00001524                           562  
00001524  1F02                     563  hta_continue    MOVE.B  D2,-(A7)            * Add the ASCII value to the stack
00001526  E898                     564                  ROR.L   #4,D0               * Rotate right by 4 to get the next character
00001528  5341                     565                  SUBI    #1,D1               * Subtract 1 from the counter
0000152A  B23C 0000                566                  CMP.B   #0,D1               * Compare the counter to 0
0000152E  66DA                     567                  BNE     hta_loop            * Branch to convert the next character if counter is not 0
00001530                           568                  
00001530  12DF                     569  hta_result      MOVE.B  (A7)+,(A1)+         * Retrieve ASCII values from the stack and put them in A1
00001532  5343                     570                  SUBI    #1,D3               * Subtract 1 from the counter
00001534  B63C 0000                571                  CMP.B   #0,D3               * Compare the counter to 0
00001538  66F6                     572                  BNE     hta_result          * Branch to retrieve the next character if counter is not 0
0000153A  4CDF 000D                573                  MOVEM.L (A7)+,D0/D2-D3      * Retrieve original data for the register
0000153E                           574  
0000153E  4E75                     575  hta_finish      RTS                         * Return
00001540                           576  *////////////////////////////////////////////////////////////////////////////////////////
00001540                           577  *odd_error: The provided address was odd, so print an error and return a -1 for the address.
00001540                           578  *////////////////////////////////////////////////////////////////////////////////////////
00001540  43F9 00001630            579  hta_error       LEA     hta_error_msg,A1    * Assign hex to ascii error message into A1
00001546  103C 000E                580                  MOVE.B  #14,D0              * Assign task code for message into D0
0000154A  4E4F                     581                  TRAP    #15                 * Display message
0000154C  4E75                     582                  RTS                         * Return
0000154E                           583  ***************************************************************************************************
0000154E                           584  ***************************************************************************************************
0000154E                           585  *
0000154E                           586  * VARIABLES
0000154E                           587  *
0000154E                           588  ***************************************************************************************************
0000154E                           589  ***************************************************************************************************
0000154E  =0000000D                590  CR              EQU     $0D                 * ASCII code for Carriage Return
0000154E  =0000000A                591  LF              EQU     $0A                 * ASCII code for Line Feed
0000154E= 57 65 6C 63 6F 6D ...    592  greeting        DC.B    'Welcome to EASY68K Disassembler!',CR,LF,0
00001571= 45 6E 74 65 72 20 ...    593  start_prompt    DC.B    'Enter starting address: ($0 to $00FFFFFE)',CR,LF,0
0000159D= 45 6E 74 65 72 20 ...    594  end_prompt      DC.B    'Enter ending address: (start to $00FFFFE)',CR,LF,0
000015C9= 54 68 65 72 65 20 ...    595  input_error     DC.B    'There was something wrong with the input',CR,LF,0
000015F4= 54 68 65 20 73 70 ...    596  not_even        DC.B    'The specified address was odd',CR,LF,0
00001614= 41 6C 6C 20 64 6F ...    597  end_message     DC.B    'All done!  See you later!',CR,LF,0
00001630= 54 68 65 20 6E 75 ...    598  hta_error_msg   DC.B    'The number of bytes was incorrect',CR,LF,0
00001654                           599  buffer          DS.B    80
000016A4                           600  start_input     DS.B    80
000016F4                           601  end_input       DS.B    80
00001744                           602  
00001744                           603  
00001744                           604      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_TO_HEX        1450
BEGIN               0
BOUND_ERROR         14B6
BUFFER              1654
CODE0000            1178
CODE0001            117C
CODE0010            11CE
CODE0011            1220
CODE0100            1272
CODE0101            1276
CODE0110            127A
CODE0111            127E
CODE1000            1282
CODE1001            1286
CODE1010            128A
CODE1011            128E
CODE1100            1292
CODE1101            1296
CODE1110            129A
CODE1111            129E
CR                  D
CURRENT             0
DATA_ERROR          12A2
DECODED             14AE
EAMODE              12C8
EAMODE0             1308
EAMODE1             1314
EAMODE2             1320
EAMODE3             1334
EAMODE4             134C
EAMODE5             1364
EAMODE6             13A2
EAMODE7             13E0
END                 FFFFFE
END_CHECK           12B8
END_INPUT           16F4
END_MESSAGE         1614
END_PROMPT          159D
EVEN_CHECK          14C6
GET_BYTE            13F8
GET_END             1050
GET_LONG            1424
GET_START           1010
GET_WORD            140E
GREETING            154E
HEX_TO_ASCII        14EC
HTA_CONTINUE        1524
HTA_ERROR           1540
HTA_ERROR_MSG       1630
HTA_FINISH          153E
HTA_LOOP            150A
HTA_NUMBER          1520
HTA_RESULT          1530
IMMEDIATE_DATA      143A
INPUT_ERROR         15C9
JMP_TABLE           1118
LF                  A
MAIN                108E
NOT_EVEN            15F4
ODD_ERROR           14DA
OP_CODE             10C6
PRINT               10AC
RESULT              14B4
SHIFT               C
STACK               7000
START               1000
START_INPUT         16A4
START_PROMPT        1571
TRANSLATE           146A
UPPERCASE           14AA
